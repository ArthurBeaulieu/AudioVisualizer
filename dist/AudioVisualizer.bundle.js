/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/AudioVisualizer.js":
/*!***********************************!*\
  !*** ./src/js/AudioVisualizer.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _scss_audiovisualizer_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scss/audiovisualizer.scss */ \"./src/scss/audiovisualizer.scss\");\n/* harmony import */ var _components_FrequencyBars_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/FrequencyBars.js */ \"./src/js/components/FrequencyBars.js\");\n/* harmony import */ var _components_FrequencyCircle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/FrequencyCircle.js */ \"./src/js/components/FrequencyCircle.js\");\n/* harmony import */ var _components_Oscilloscope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/Oscilloscope.js */ \"./src/js/components/Oscilloscope.js\");\n/* harmony import */ var _components_PeakMeter_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/PeakMeter.js */ \"./src/js/components/PeakMeter.js\");\n/* harmony import */ var _components_Spectrum_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/Spectrum.js */ \"./src/js/components/Spectrum.js\");\n/* harmony import */ var _components_Timeline_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/Timeline.js */ \"./src/js/components/Timeline.js\");\n/* harmony import */ var _components_Waveform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/Waveform.js */ \"./src/js/components/Waveform.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\n\n\n\n\nvar AudioVisualizerVersion = '1.0.0';\nwindow.AudioContext = window.AudioContext || window.webkitAudioContext;\nvar AudioVisualizer = /*#__PURE__*/function () {\n  /** @summary AudioVisualizer factory class to build all supported visualisation\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>This factory will return an <code>AudioVisualizer</code> component. It is\r\n   * automatically rendered, and will also be automatically linked to given audio source. No further manipulation\r\n   * are required (except destroy when done using) on runtime.<br><br>Each components have shared properties,\r\n   * and unique properties, as described in components class themselves. Refer to the components documentation for\r\n   * specific options.<br><br>Multi visualisation can have an impact on CPU load that mostly depends on client configuration.\r\n   * Keep that in mind if you develop your project with a battle station. When done using a component, please call its\r\n   * <code>destroy</code> method to remove listeners and audio processing to avoid memory leaks in your app.</blockquote>\r\n   * @param {object} options - The audio visualisation definition\r\n   * @param {string} options.type - The visualisation type, can be <code>bars</code>/<code>circle</code>/<code>oscilloscope</code>/<code>peakmeter</code>/<code>spectrum</code>/<code>timeline</code>/<code>waveform</code>\r\n   * @param {object} options.player - A DOM audio player to be the audio source for processing\r\n   * @param {object} options.renderTo - A DOM element to render the visualisation in. It will automatically scale content to this element's dimension\r\n   * @param {object} [options.audioContext=null] - A WebAudioAPI audio context to chain the processing nodes in your audio routing.\r\n   * @param {object} [options.inputNode=null] - The WebAudioAPI audio node to be the audio source for processing, You must provide an audioContext\r\n   * @param {number} [options.fftSize=1024] - The FFT size to use in processing, must be a power of 2. High values cost more CPU\r\n   * @returns {object|null} - The custom visualisation component according to given options, <code>null</code> for unknown type */\n  function AudioVisualizer(options) {\n    _classCallCheck(this, AudioVisualizer);\n    if (options.type === 'bars') {\n      return new _components_FrequencyBars_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](options);\n    } else if (options.type === 'circle') {\n      return new _components_FrequencyCircle_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](options);\n    } else if (options.type === 'oscilloscope') {\n      return new _components_Oscilloscope_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](options);\n    } else if (options.type === 'peakmeter') {\n      return new _components_PeakMeter_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](options);\n    } else if (options.type === 'spectrum') {\n      return new _components_Spectrum_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](options);\n    } else if (options.type === 'timeline') {\n      return new _components_Timeline_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](options);\n    } else if (options.type === 'waveform') {\n      return new _components_Waveform_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](options);\n    }\n    // Visualizer factory return null by default (unknown component name)\n    return null;\n  }\n\n  /** @public\r\n   * @member {string} - The AudioVisualizer component version */\n  return _createClass(AudioVisualizer, null, [{\n    key: \"version\",\n    get: function get() {\n      return AudioVisualizerVersion;\n    }\n  }]);\n}(); // Global scope attachment will be made when bundling this file\nwindow.AudioVisualizer = AudioVisualizer;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AudioVisualizer);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/AudioVisualizer.js?");

/***/ }),

/***/ "./src/js/components/FrequencyBars.js":
/*!********************************************!*\
  !*** ./src/js/components/FrequencyBars.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/VisuComponentMono.js */ \"./src/js/utils/VisuComponentMono.js\");\n/* harmony import */ var _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/CanvasUtils.js */ \"./src/js/utils/CanvasUtils.js\");\n/* harmony import */ var _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ColorUtils.js */ \"./src/js/utils/ColorUtils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar FrequencyBars = /*#__PURE__*/function (_VisuComponentMono) {\n  /** @summary FrequencyBars displays the audio spectrum as frequency bars in real time.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments VisuComponentMono\r\n   * @description <blockquote>This will display a single canvas with frequency from left to right be bass to high. The bar\r\n   * height depends on audio bin intensity. The audio graph is then draw with a gradient from bottom to top that is from\r\n   * green to red. Those color can be custom ones (see constructor options).</blockquote>\r\n   * @param {object} options - The frequency bars options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {object[]} [options.colors] - The peak meter gradient colors, must be objects with color (in Hex/RGB/HSL) and index (in Float[0,1]) properties **/\n  function FrequencyBars(options) {\n    var _this;\n    _classCallCheck(this, FrequencyBars);\n    _this = _callSuper(this, FrequencyBars, [options]);\n    // Peak gradient\n    if (!options.colors || !options.colors.gradient) {\n      _this._barGradient = _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultAudioGradient;\n    } else {\n      _this._barGradient = options.colors.gradient;\n    }\n    // Update canvas CSS background color\n    _this._canvas.style.backgroundColor = options.colors ? options.colors.background || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor;\n    return _this;\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  --------------------------------------  VISUCOMPONENTMONO OVERRIDES  -----------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name _processAudioBin\r\n   * @private\r\n   * @override\r\n   * @memberof FrequencyBars\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Real time method called by WebAudioAPI to process PCM data. Here we make a 8 bit frequency\r\n   * analysis. Then we use utils method to draw bar for each audio bin in studied audio spectrum.</blockquote> **/\n  _inherits(FrequencyBars, _VisuComponentMono);\n  return _createClass(FrequencyBars, [{\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      // Only fill again the canvas if player is playing\n      if (this._isPlaying === true) {\n        this._clearCanvas();\n        // Get frequency data for current bin in node analyser\n        var frequencyData = new Uint8Array(this._nodes.analyser.frequencyBinCount);\n        this._nodes.analyser.getByteFrequencyData(frequencyData);\n        // Compute single frequency width according to analyser node\n        var frequencyWidth = this._canvas.width / this._nodes.analyser.frequencyBinCount;\n        // Iterate over data to build each bar\n        var cursorX = 0; // X origin for items in loop\n        for (var i = 0; i < this._nodes.analyser.frequencyBinCount; ++i) {\n          // Compute frequency height in px, relative to the canvas height\n          var frequencyHeight = frequencyData[i] / 255 * this._canvas.height;\n          _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawVerticalBar(this._canvas, {\n            height: frequencyHeight,\n            width: frequencyWidth,\n            colors: this._barGradient,\n            originX: cursorX\n          });\n          // Update cursor position\n          cursorX += frequencyWidth;\n        }\n        // Draw next frame\n        requestAnimationFrame(this._processAudioBin);\n      }\n    }\n  }]);\n}(_utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FrequencyBars);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/components/FrequencyBars.js?");

/***/ }),

/***/ "./src/js/components/FrequencyCircle.js":
/*!**********************************************!*\
  !*** ./src/js/components/FrequencyCircle.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/VisuComponentMono.js */ \"./src/js/utils/VisuComponentMono.js\");\n/* harmony import */ var _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/CanvasUtils.js */ \"./src/js/utils/CanvasUtils.js\");\n/* harmony import */ var _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ColorUtils.js */ \"./src/js/utils/ColorUtils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar FrequencyCircle = /*#__PURE__*/function (_VisuComponentMono) {\n  /** @summary FrequencyCircle displays a stylistic radial view in real time.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments VisuComponentMono\r\n   * @description <blockquote>This will display a single canvas with frequency displayed in. Inspired from\r\n   * https://www.kkhaydarov.com/audio-visualizer/ and https://codepen.io/noeldelgado/pen/EaNjBy aka real mvps\r\n   * that helped going through WebAudioAPI. It will combine a radial gradient in the background, a spinning logo\r\n   * in the canvas center, radial frequency bars, radial oscilloscope, linear oscilloscope with it visibility handled\r\n   * by real time audio intensity, as well as circular pulsing and glowing circle around the logo.</blockquote>\r\n   * @param {object} options - The frequency circle options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one **/\n  function FrequencyCircle(options) {\n    _classCallCheck(this, FrequencyCircle);\n    return _callSuper(this, FrequencyCircle, [options]);\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  --------------------------------------  VISUCOMPONENTMONO OVERRIDES  -----------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof FrequencyCircle\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The frequency circle options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {string} [options.image] - The image to put in center of canvas with a spinning animation **/\n  _inherits(FrequencyCircle, _VisuComponentMono);\n  return _createClass(FrequencyCircle, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      _superPropGet(FrequencyCircle, \"_fillAttributes\", this, 3)([options]);\n      // Frequency circle specific attributes\n      this._imageSrc = null;\n      this._centerX = null;\n      this._centerY = null;\n      this._radius = null;\n      this._radialSection = null;\n      this._barCount = null;\n      this._barMaxHeight = null;\n      this._circleStrokeWidth = null;\n      this._stars = [];\n      this._points = [];\n      this._oscilloscopeRotation = null;\n      // Dom specific elements for frequency circle\n      this._dom.logo = null;\n      // Intensity modifier\n      this._averageBreakpoint = 132; // Putting breakpoint on mid amplitude [0, 255]\n      this._averageHit = false;\n      this._imageSrc = options.image;\n      this._dom.logo = document.createElement('IMG');\n      this._dom.logo.classList.add('paused');\n      this._dom.logo.src = this._imageSrc;\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @override\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create and configure canvas then append it to given DOM element.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      _superPropGet(FrequencyCircle, \"_buildUI\", this, 3)([]);\n      if (this._imageSrc) {\n        this._dom.container.appendChild(this._dom.logo);\n      }\n      this._buildBackgroundBase();\n    }\n\n    /** @method\r\n     * @name _play\r\n     * @private\r\n     * @override\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On play event callback.</blockquote> **/\n  }, {\n    key: \"_play\",\n    value: function _play() {\n      _superPropGet(FrequencyCircle, \"_play\", this, 3)([]);\n      this._dom.logo.classList.remove('paused'); // Resume scss animation\n    }\n\n    /** @method\r\n     * @name _pause\r\n     * @private\r\n     * @override\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On pause event callback.</blockquote> **/\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      _superPropGet(FrequencyCircle, \"_pause\", this, 3)([]);\n      this._dom.logo.classList.add('paused'); // Pause scss animation\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @override\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      _superPropGet(FrequencyCircle, \"_onResize\", this, 3)([]);\n      this._circleStrokeWidth = 2;\n      this._barCount = this._nodes.analyser.frequencyBinCount;\n      this._centerX = this._canvas.width / 2;\n      this._centerY = this._canvas.height / 2;\n      this._barMaxHeight = this._canvas.height / 8;\n      this._radius = this._canvas.height / 4 - this._canvas.height / 16;\n      this._radialSection = Math.PI * 2 / this._barCount;\n      // Populating stars\n      this._stars = [];\n      for (var i = 0; i < 1500; ++i) {\n        this._stars.push(new BackgroundStar(this._centerX, this._centerY, null, this._averageBreakpoint));\n      }\n      // Populating circular oscilloscope points\n      this._points = [];\n      for (var _i = 0; _i < this._fftSize / 2; ++_i) {\n        this._points.push(new OscilloscopeRadialPoint({\n          index: _i,\n          height: this._canvas.height,\n          width: this._canvas.width,\n          total: this._fftSize / 2\n        }));\n      }\n      // Build canvas fixed base\n      this._buildBackgroundBase();\n    }\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @override\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Real time method called by WebAudioAPI to process PCM data. Here we make a 8 bit frequency\r\n     * and time analysis. Then we use utils method to draw radial oscilloscope, linear point oscilloscope, background points\r\n     * and radial frequency bars.</blockquote> **/\n  }, {\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      if (this._isPlaying === true) {\n        this._clearCanvas();\n        this._buildBackgroundBase();\n        // Extract frequencies and times data\n        var frequencies = new Uint8Array(this._nodes.analyser.frequencyBinCount);\n        var times = new Uint8Array(this._nodes.analyser.frequencyBinCount);\n        this._nodes.analyser.getByteFrequencyData(frequencies);\n        this._nodes.analyser.getByteTimeDomainData(times);\n        // Get average frequency for proccessed bin\n        var average = this._getAverageFrequency(frequencies);\n        this._averageHit = average > this._averageBreakpoint;\n        // Draw circle bars while retrieving aaverage amplitude\n        this._animateCircleBars(frequencies);\n        // Animate each star\n        this._animateStars(average);\n        // Draw average circle with its glow effect around center\n        this._animateCircleGlow(average);\n        // Draw circular oscilloscope and horizontal one if average hit\n        this._animateOscilloscopes(times);\n        // Request for next frame\n        requestAnimationFrame(this._processAudioBin);\n      }\n    }\n\n    /*  ----------  FrequencyCircle internal methods  ----------  */\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw radial gradient background and circle that surround image.</blockquote> **/\n  }, {\n    key: \"_buildBackgroundBase\",\n    value: function _buildBackgroundBase() {\n      // Build background radial gradient\n      // Color value according to ManaZeak's linear background colors\n      _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawRadialGradient(this._canvas, {\n        x0: this._centerX,\n        y0: this._centerY,\n        r0: this._radius,\n        x1: this._centerX,\n        y1: this._centerY,\n        r1: this._canvas.width / 2.66,\n        colors: [{\n          color: '#3C405D',\n          index: 0\n        }, {\n          color: '#060609',\n          index: 1\n        }]\n      });\n      // Build logo circle border\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawCircle(this._canvas, {\n        centerX: this._centerX,\n        centerY: this._centerY,\n        radius: this._radius,\n        radStart: 0,\n        radEnd: Math.PI * 2,\n        width: this._circleStrokeWidth * 2 // Times two because stroke is centered on circle\n      });\n    }\n\n    /** @method\r\n     * @name _animateCircleBars\r\n     * @private\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Compute the frequency circle shape according to audio BIN frequency array.</blockquote>\r\n     * @param {number[]} frequencies - The frequency array for a given audio bin **/\n  }, {\n    key: \"_animateCircleBars\",\n    value: function _animateCircleBars(frequencies) {\n      // Compute radial width for each circular bar\n      var barWidth = Math.round(this._radialSection * this._radius);\n      // Iterate over frequencies to draw each matching frequency bin\n      for (var i = 0; i < frequencies.length; ++i) {\n        // Compute current bar height depending on intensity\n        var barHeight = frequencies[i] / 255 * this._barMaxHeight;\n        // Use CanvasUtils to draw bar\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawRadialBar(this._canvas, {\n          frequencyValue: frequencies[i],\n          x0: this._centerX + Math.cos(this._radialSection * i - Math.PI / 2) * (this._radius + this._circleStrokeWidth),\n          y0: this._centerY + Math.sin(this._radialSection * i - Math.PI / 2) * (this._radius + this._circleStrokeWidth),\n          x1: this._centerX + Math.cos(this._radialSection * i - Math.PI / 2) * (this._radius + this._circleStrokeWidth + barHeight),\n          y1: this._centerY + Math.sin(this._radialSection * i - Math.PI / 2) * (this._radius + this._circleStrokeWidth + barHeight),\n          width: barWidth,\n          color: this._averageHit ? '#56D45B' : '#37C340'\n        });\n      }\n    }\n\n    /** @method\r\n     * @name _animateStars\r\n     * @private\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Animate background points to match intensity with color and radius.</blockquote>\r\n     * @param {number} average - The average value that acts like a breakpoint for intensity **/\n  }, {\n    key: \"_animateStars\",\n    value: function _animateStars(average) {\n      var tick = this._averageHit ? average / 20 : average / 60;\n      for (var i = 0; i < this._stars.length; ++i) {\n        var star = this._stars[i];\n        // Update star position and variation\n        star.updatePosition(tick, 0.6);\n        // Replace star with new one if it went out canvas\n        if (star.x < -this._centerX || star.x > this._centerX || star.y < -this._centerY || star.y > this._centerY) {\n          star = new BackgroundStar(this._centerX, this._centerY, average, this._averageBreakpoint); // Update local variable\n          this._stars[i] = star; // Save new reference\n        }\n        // Use CanvasUtils to draw star disc\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawDisc(this._canvas, {\n          centerX: star.x + this._centerX,\n          centerY: star.y + this._centerY,\n          radius: star.radius,\n          radStart: Math.PI * 2,\n          radEnd: false,\n          color: star.color\n        });\n      }\n    }\n\n    /** @method\r\n     * @name _animateCircleGlow\r\n     * @private\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Animate the glowing circle around centred logo.</blockquote>\r\n     * @param {number} average - The average value that acts like a breakpoint for intensity **/\n  }, {\n    key: \"_animateCircleGlow\",\n    value: function _animateCircleGlow(average) {\n      // Build average amplitude glow with color change when average breakpoint is hit\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawCircleGlow(this._canvas, {\n        centerX: this._centerX,\n        centerY: this._centerY,\n        radius: (this._radius * 1.33 + average) * 2,\n        // Glow need twice radius to properly display gradient\n        radStart: 0,\n        radEnd: Math.PI * 2,\n        colors: [{\n          color: 'rgba(0, 0, 0, 0)',\n          index: 0.48\n        }, {\n          color: this._averageHit ? /* Green */'#56D45B' : /* Blue */'#48ABAF',\n          index: 0.5\n        }, {\n          color: 'rgba(0, 0, 0, 0)',\n          index: 0.52\n        }]\n      });\n    }\n\n    /** @method\r\n     * @name _animateOscilloscopes\r\n     * @private\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw both radial and linear point oscilloscopes.</blockquote>\r\n     * @param {number[]} times - The time domain for a given audio bin **/\n  }, {\n    key: \"_animateOscilloscopes\",\n    value: function _animateOscilloscopes(times) {\n      var tick = 0.05;\n      var color = '#FFF';\n      if (this._averageHit) {\n        this._oscilloscopeRotation += tick;\n        color = 'rgba(255, 193, 140, .7)'; // Orange\n      } else {\n        this._oscilloscopeRotation += -tick;\n        color = 'rgba(125, 228, 132, 0.25)'; // Green\n      }\n      // Update radial oscilloscope with time values\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawRadialOscilloscope(this._canvas, {\n        points: this._points,\n        times: times,\n        length: this._fftSize / 2,\n        centerX: this._centerX,\n        centerY: this._centerY,\n        rotation: this._oscilloscopeRotation,\n        color: color\n      });\n      // If breakpoint is reached, we draw stillized horizontal oscilloscope\n      if (this._averageHit) {\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawPointsOscilloscope(this._canvas, {\n          times: times,\n          length: this._fftSize / 2,\n          color: 'rgba(113, 201, 205, .7)'\n        });\n      }\n    }\n\n    /** @method\r\n     * @name _getAverageFrequency\r\n     * @private\r\n     * @memberof FrequencyCircle\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Compute the average value for a given audio bin.</blockquote>\r\n     * @param {number[]} frequencies - The frequency array for a given audio bin\r\n     * @return {number} - The average value for a frequency bin **/\n  }, {\n    key: \"_getAverageFrequency\",\n    value: function _getAverageFrequency(frequencies) {\n      var average = 0; // Output average value\n      for (var i = 0; i < frequencies.length; ++i) {\n        // Update average amplitude value\n        average += frequencies[i];\n      }\n      // Return average value of frequencies\n      return average / frequencies.length;\n    }\n  }]);\n}(_utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/*  ----------  Utils class for this visualisation  ----------  */\nvar BackgroundStar = /*#__PURE__*/function () {\n  /** @summary BackgroundStar handle stars in frequency circle.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>This will display a single canvas with frequency displayed with.</blockquote>\r\n   * @param {number} centerX - The start x origin\r\n   * @param {number} centerY - The start y origin\r\n   * @param {number} [average=0] - The audio bin average value\r\n   * @param {number} [breakpoint=132] - The size and color breakpoint value to be compared with average **/\n  function BackgroundStar(centerX, centerY) {\n    var average = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var breakpoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 132;\n    _classCallCheck(this, BackgroundStar);\n    // Public attributes\n    this.radius = 0.4;\n    this.color = '#0F8489'; // Dark blue\n    this.x = Math.random() * (centerX * 2) - centerX;\n    this.y = Math.random() * (centerY * 2) - centerY;\n    // Private attributes\n    this._z = Math.max(centerX * 2 / (centerY * 2));\n    this._maxDepth = Math.max(centerX * 2 / (centerY * 2));\n    // Set star variation in space\n    if (Math.abs(this.x) > Math.abs(this.y)) {\n      this._dx = 1.0;\n      this._dy = Math.abs(this.y / this.x);\n    } else {\n      this._dx = Math.abs(this.x / this.y);\n      this._dy = 1.0;\n    }\n    // Set variation relative to center\n    this._dx *= this.x > 0 ? 1 : -1;\n    this._dy *= this.y > 0 ? 1 : -1;\n    this._dz = -0.1;\n    // Determine color according to center or average intensity\n    if (this.y > centerY / 2) {\n      this.color = '#71C9CD'; // Light Blue\n    } else if (average > breakpoint) {\n      this.color = '#FF6B67'; // Red\n    }\n  }\n\n  /** @method\r\n   * @name updatePosition\r\n   * @public\r\n   * @memberof BackgroundStar\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Update the background star position.</blockquote>\r\n   * @param {number} tick - The multiplier value for position variation\r\n   * @param {number} radiusFactor - The star radius variation factor **/\n  return _createClass(BackgroundStar, [{\n    key: \"updatePosition\",\n    value: function updatePosition(tick, radiusFactor) {\n      // Update position\n      this.x += this._dx * tick;\n      this.y += this._dy * tick;\n      this._z += this._dz; // Constant z variation\n      // Update variation\n      this._dx += this._dx * .001;\n      this._dy += this._dy * .001;\n      this.radius = radiusFactor + (this._maxDepth - this._z) * .1;\n    }\n  }]);\n}();\nvar OscilloscopeRadialPoint = /*#__PURE__*/_createClass(\n/** @summary OscilloscopeRadialPoint handle each point in circular oscilloscope.\r\n * @author Arthur Beaulieu\r\n * @since 2020\r\n * @description <blockquote>Create a container for oscilloscope point. Edit radius, x and y public attributes.</blockquote>\r\n * @param {object} options - The oscilloscope radial point option\r\n * @param {number} options.height - The point height\r\n * @param {number} options.width - The point width\r\n * @param {number} options.total - The divider value for angle\r\n * @param {number} options.index - The numerator value for angle **/\nfunction OscilloscopeRadialPoint(options) {\n  _classCallCheck(this, OscilloscopeRadialPoint);\n  this._height = options.height;\n  this._width = options.width;\n  this._total = options.total;\n  this._index = options.index;\n  this._value = Math.random() * 256;\n  this._radius = Math.abs(this._width) / 8;\n  // Public attributes\n  this.angle = this._index * 360 / this._total;\n  this.x = this._width / 2 + this._radius * Math.sin(Math.PI / 180 * this.angle);\n  this.y = this._height / 2 + this._radius * Math.cos(Math.PI / 180 * this.angle);\n  this.dx = this.x + this._value * Math.sin(Math.PI / 180 * this.angle);\n  this.dy = this.y + this._value * Math.cos(Math.PI / 180 * this.angle);\n});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FrequencyCircle);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/components/FrequencyCircle.js?");

/***/ }),

/***/ "./src/js/components/Oscilloscope.js":
/*!*******************************************!*\
  !*** ./src/js/components/Oscilloscope.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_VisuComponentStereo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/VisuComponentStereo.js */ \"./src/js/utils/VisuComponentStereo.js\");\n/* harmony import */ var _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/CanvasUtils.js */ \"./src/js/utils/CanvasUtils.js\");\n/* harmony import */ var _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ColorUtils.js */ \"./src/js/utils/ColorUtils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar Oscilloscope = /*#__PURE__*/function (_VisuComponentStereo) {\n  /** @summary Oscilloscope displays a merged or L/R oscilloscope in real time.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments VisuComponentStereo\r\n   * @description <blockquote>This will display a single/dual canvas with frequency displayed with.</blockquote>\r\n   * @param {object} options - The oscilloscope options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {boolean} [options.merged=false] - Merge left and right channel into one output\r\n   * @param {string} [options.colors] - The oscilloscope background and signal color\r\n   * @param {string} [options.colors.signal=ColorUtils.defaultPrimaryColor] - The signal color\r\n   * @param {string} [options.colors.background=ColorUtils.defaultPrimaryColor] - The background color **/\n  function Oscilloscope(options) {\n    var _this;\n    _classCallCheck(this, Oscilloscope);\n    _this = _callSuper(this, Oscilloscope, [options]);\n    // Define default oscillo color\n    _this._colors = {\n      signal: _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultPrimaryColor\n    };\n    // Save color sent by caller if any\n    if (options.colors && options.colors.signal) {\n      _this._colors.signal = options.colors.signal;\n    }\n    // Update canvas CSS background color\n    var bgColor = options.colors ? options.colors.background || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor;\n    if (_this._merged === true) {\n      _this._canvas.style.backgroundColor = bgColor;\n    } else {\n      _this._canvasL.style.backgroundColor = bgColor;\n      _this._canvasR.style.backgroundColor = bgColor;\n    }\n    // Init oscilloscope dimensions\n    _this._updateDimensions();\n    return _this;\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  -------------------------------------  VISUCOMPONENTSTEREO OVERRIDES  ----------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof Oscilloscope\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The oscilloscope options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one **/\n  _inherits(Oscilloscope, _VisuComponentStereo);\n  return _createClass(Oscilloscope, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      _superPropGet(Oscilloscope, \"_fillAttributes\", this, 3)([options]);\n\n      // Dimensions will be computed when canvas have been created\n      this._dimension = {\n        height: null,\n        canvasHeight: null,\n        width: null\n      };\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @override\r\n     * @memberof Oscilloscope\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create and configure canvas then append it to given DOM element.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      _superPropGet(Oscilloscope, \"_buildUI\", this, 3)([]);\n      if (this._merged === true) {\n        this._dom.container.removeChild(this._canvasR);\n      }\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @override\r\n     * @memberof Oscilloscope\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      _superPropGet(Oscilloscope, \"_onResize\", this, 3)([]);\n      this._updateDimensions();\n    }\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @override\r\n     * @memberof Oscilloscope\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Real time method called by WebAudioAPI to process PCM data. Here we make a 8 bit time\r\n     * analysis.</blockquote> **/\n  }, {\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      if (this._isPlaying === true) {\n        this._clearCanvas();\n        if (this._merged === true) {\n          this._mergedStereoAnalysis();\n        } else {\n          this._stereoAnalysis();\n        }\n        // Draw next frame\n        requestAnimationFrame(this._processAudioBin);\n      }\n    }\n\n    /*  ----------  Oscilloscope internal methods  ----------  */\n\n    /** @method\r\n     * @name _mergedStereoAnalysis\r\n     * @private\r\n     * @memberof Oscilloscope\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform a merged Left and Right analysis with 8 bit time domain data.</blockquote> **/\n  }, {\n    key: \"_mergedStereoAnalysis\",\n    value: function _mergedStereoAnalysis() {\n      // Create TimeDomain array with frequency bin length\n      var timeDomain = new Uint8Array(this._nodes.analyser.frequencyBinCount);\n      // Left/Right channel\n      this._nodes.analyser.getByteTimeDomainData(timeDomain);\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawOscilloscope(this._canvasL, {\n        samples: this._nodes.analyser.frequencyBinCount,\n        timeDomain: timeDomain,\n        colors: this._colors.signal\n      });\n    }\n\n    /** @method\r\n     * @name _stereoAnalysis\r\n     * @private\r\n     * @memberof Oscilloscope\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform a separated Left and Right analysis with 8 bit time domain data.</blockquote> **/\n  }, {\n    key: \"_stereoAnalysis\",\n    value: function _stereoAnalysis() {\n      // Create TimeDomain array with freqency bin length\n      var timeDomain = new Uint8Array(this._nodes.analyserL.frequencyBinCount);\n      // Left channel\n      this._nodes.analyserL.getByteTimeDomainData(timeDomain);\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawOscilloscope(this._canvasL, {\n        samples: this._nodes.analyserL.frequencyBinCount,\n        timeDomain: timeDomain,\n        colors: this._colors.signal\n      });\n      // Right channel\n      this._nodes.analyserR.getByteTimeDomainData(timeDomain);\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawOscilloscope(this._canvasR, {\n        samples: this._nodes.analyserR.frequencyBinCount,\n        timeDomain: timeDomain,\n        colors: this._colors.signal\n      });\n    }\n\n    /** @method\r\n     * @name _updateDimensions\r\n     * @private\r\n     * @memberof Oscilloscope\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Usually called on resize event, update canvas dimension to fit render to DOM object.</blockquote> **/\n  }, {\n    key: \"_updateDimensions\",\n    value: function _updateDimensions() {\n      this._dimension.height = this._renderTo.offsetHeight - 4; // 2px borders times two channels\n      this._dimension.width = this._renderTo.offsetWidth - 2; // 2px borders\n      this._dimension.canvasHeight = this._dimension.height / 2;\n      if (this._merged === true) {\n        this._canvasL.width = this._dimension.width;\n        this._canvasL.height = this._dimension.canvasHeight * 2;\n      } else {\n        this._canvasL.width = this._dimension.width;\n        this._canvasL.height = this._dimension.canvasHeight;\n        this._canvasR.width = this._dimension.width;\n        this._canvasR.height = this._dimension.canvasHeight;\n      }\n    }\n  }]);\n}(_utils_VisuComponentStereo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Oscilloscope);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/components/Oscilloscope.js?");

/***/ }),

/***/ "./src/js/components/PeakMeter.js":
/*!****************************************!*\
  !*** ./src/js/components/PeakMeter.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_VisuComponentStereo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/VisuComponentStereo.js */ \"./src/js/utils/VisuComponentStereo.js\");\n/* harmony import */ var _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/CanvasUtils.js */ \"./src/js/utils/CanvasUtils.js\");\n/* harmony import */ var _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ColorUtils.js */ \"./src/js/utils/ColorUtils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar PeakMeter = /*#__PURE__*/function (_VisuComponentStereo) {\n  /** @summary PeakMeter displays a splited or merged peak meter for audio signal\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments VisuComponentStereo\r\n   * @description <blockquote>This component display a peak meter in several configuration. It can include a scale and its legend\r\n   * and be oriented vertically or horizontally. Modified https://github.com/esonderegger/web-audio-peak-meter</blockquote>\r\n   * @param {object} options - The peak meter options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {boolean} [options.merged=false] - Merge left and right channel into one output\r\n   * @param {object} [options.legend] - The peak meter legend options\r\n   * @param {number} [options.legend.dbScaleMin=60] - The min scale value\r\n   * @param {number} [options.legend.dbScaleTicks=6] - The tick distance, must be a multiple of scale min\r\n   * @param {object} [options.colors] - The oscilloscope background and signal color\r\n   * @param {string} [options.colors.background=ColorUtils.defaultPrimaryColor] - The background color\r\n   * @param {string} [options.colors.min=#56D45B] - The gradient min value\r\n   * @param {string} [options.colors.step0=#AFF2B3] - The gradient second value\r\n   * @param {string} [options.colors.step1=#FFAD67] - The gradient third value\r\n   * @param {string} [options.colors.step2=#FF6B67] - The gradient fourth value\r\n   * @param {string} [options.colors.max=#FFBAB8] - The gradient max value **/\n  function PeakMeter(options) {\n    var _this;\n    _classCallCheck(this, PeakMeter);\n    _this = _callSuper(this, PeakMeter, [options]);\n    // Peak gradient\n    if (!options.colors || !options.colors.gradient) {\n      _this._peakGradient = _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultAudioGradient;\n    } else {\n      _this._peakGradient = options.colors.gradient;\n    }\n    // Update canvas CSS background color\n    var bgColor = options.colors ? options.colors.background || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor;\n    if (_this._merged === true) {\n      _this._canvasL.style.backgroundColor = bgColor;\n    } else {\n      _this._canvasL.style.backgroundColor = bgColor;\n      _this._canvasR.style.backgroundColor = bgColor;\n    }\n    return _this;\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  -------------------------------------  VISUCOMPONENTSTEREO OVERRIDES  ----------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof PeakMeter\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The frequency circle options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one **/\n  _inherits(PeakMeter, _VisuComponentStereo);\n  return _createClass(PeakMeter, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      _superPropGet(PeakMeter, \"_fillAttributes\", this, 3)([options]);\n      this._orientation = options.orientation || 'horizontal';\n      this._legend = options.legend || null;\n      if (this._legend) {\n        this._dbScaleMin = options.legend.dbScaleMin || 60;\n        this._dbScaleTicks = options.legend.dbScaleTicks || 15;\n      } else {\n        this._dbScaleMin = 60;\n        this._dbScaleTicks = 15;\n      }\n      this._amplitudeL = 0;\n      this._amplitudeR = 0;\n      this._peakL = 0;\n      this._peakR = 0;\n      this._peakSetTimeL = null;\n      this._peakSetTimeR = null;\n      this._dom.scaleContainer = null;\n      this._dom.labels = [];\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @override\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create and configure canvas then append it to given DOM element.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      _superPropGet(PeakMeter, \"_buildUI\", this, 3)([]);\n      if (this._orientation === 'horizontal') {\n        this._dom.container.classList.add('horizontal-peakmeter');\n      }\n      if (this._legend) {\n        this._dom.scaleContainer = document.createElement('DIV');\n        this._dom.scaleContainer.classList.add('scale-container');\n        this._dom.container.insertBefore(this._dom.scaleContainer, this._dom.container.firstChild);\n      }\n      if (this._merged === true) {\n        this._dom.container.removeChild(this._canvasR);\n      }\n      this._updateDimensions();\n      if (this._legend) {\n        this._createPeakLabel();\n        this._createScaleTicks();\n      }\n    }\n\n    /** @method\r\n     * @name _setAudioNodes\r\n     * @private\r\n     * @override\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Build audio chain with source.</blockquote> **/\n  }, {\n    key: \"_setAudioNodes\",\n    value: function _setAudioNodes() {\n      _superPropGet(PeakMeter, \"_setAudioNodes\", this, 3)([]);\n      this._peakSetTimeL = this._audioCtx.currentTime;\n      this._peakSetTimeR = this._audioCtx.currentTime;\n    }\n\n    /** @method\r\n     * @name _pause\r\n     * @private\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On pause event callback.</blockquote> **/\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      _superPropGet(PeakMeter, \"_pause\", this, 3)([]);\n      if (this._legend) {\n        this._dom.labels[0].textContent = '-∞';\n        this._dom.labels[1].textContent = '-∞';\n      }\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @override\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      _superPropGet(PeakMeter, \"_onResize\", this, 3)([]);\n      this._updateDimensions();\n      if (this._legend) {\n        this._createPeakLabel();\n        this._createScaleTicks();\n      }\n    }\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @override\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Real time method called by WebAudioAPI to process PCM data. Here we make a 8 bit frequency\r\n     * and time analysis. Then we use utils method to draw radial oscilloscope, linear point oscilloscope, background points\r\n     * and radial frequency bars.</blockquote> **/\n  }, {\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      if (this._isPlaying === true) {\n        this._clearCanvas();\n        if (this._merged === true) {\n          this._mergedStereoAnalysis();\n        } else {\n          this._stereoAnalysis();\n        }\n        // Draw next frame\n        requestAnimationFrame(this._processAudioBin);\n      }\n    }\n\n    /*  ----------  PeakMeter internal methods  ----------  */\n\n    /** @method\r\n     * @name _mergedStereoAnalysis\r\n     * @private\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform a merged Left and Right analysis with 32 bit time domain data.</blockquote> **/\n  }, {\n    key: \"_mergedStereoAnalysis\",\n    value: function _mergedStereoAnalysis() {\n      var data = new Float32Array(this._fftSize);\n      this._nodes.analyser.getFloatTimeDomainData(data);\n      // Compute average power over the interval and average power attenuation in DB\n      var sumOfSquares = 0;\n      for (var i = 0; i < data.length; i++) {\n        sumOfSquares += data[i] * data[i];\n      }\n      var avgPowerDecibels = 10 * Math.log10(sumOfSquares / data.length);\n      // Compure amplitude from width or height depending on orientation\n      var dbScaleBound = this._dbScaleMin * -1;\n      if (this._orientation === 'horizontal') {\n        this._amplitudeL = Math.floor(avgPowerDecibels * this._canvasL.width / dbScaleBound);\n      } else if (this._orientation === 'vertical') {\n        this._amplitudeL = Math.floor(avgPowerDecibels * this._canvasL.height / dbScaleBound);\n      }\n      // Left channel\n      // Found a new max value (peak) [-this._dbScaleMin, 0] interval\n      if (this._peakL > this._amplitudeL) {\n        this._peakL = this._amplitudeL;\n        this._peakSetTimeL = this._audioCtx.currentTime;\n        // Update peak label\n        if (this._legend) {\n          avgPowerDecibels !== -Infinity ? this._dom.labels[0].textContent = _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].precisionRound(avgPowerDecibels, 1) : null;\n        }\n      } else if (this._audioCtx.currentTime - this._peakSetTimeL > 1) {\n        this._peakL = this._amplitudeL;\n        this._peakSetTimeL = this._audioCtx.currentTime;\n        // Update peak label\n        if (this._legend) {\n          avgPowerDecibels !== -Infinity ? this._dom.labels[0].textContent = _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].precisionRound(avgPowerDecibels, 1) : null;\n        }\n      }\n      // Draw left and right peak meters\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawPeakMeter(this._canvasL, {\n        amplitude: this._amplitudeL,\n        peak: this._peakL,\n        orientation: this._orientation,\n        colors: this._peakGradient\n      });\n    }\n\n    /** @method\r\n     * @name _stereoAnalysis\r\n     * @private\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform a separated Left and Right analysis with 32 bit time domain data.</blockquote> **/\n  }, {\n    key: \"_stereoAnalysis\",\n    value: function _stereoAnalysis() {\n      var dataL = new Float32Array(this._fftSize);\n      var dataR = new Float32Array(this._fftSize);\n      this._nodes.analyserL.getFloatTimeDomainData(dataL);\n      this._nodes.analyserR.getFloatTimeDomainData(dataR);\n      // Compute average power over the interval and average power attenuation in DB\n      var sumOfSquaresL = 0;\n      var sumOfSquaresR = 0;\n      for (var i = 0; i < dataL.length; i++) {\n        sumOfSquaresL += dataL[i] * dataL[i];\n        sumOfSquaresR += dataR[i] * dataR[i];\n      }\n      var avgPowerDecibelsL = 10 * Math.log10(sumOfSquaresL / dataL.length);\n      var avgPowerDecibelsR = 10 * Math.log10(sumOfSquaresR / dataR.length);\n      // Compute amplitude from width or height depending on orientation\n      var dbScaleBound = this._dbScaleMin * -1;\n      if (this._orientation === 'horizontal') {\n        this._amplitudeL = Math.floor(avgPowerDecibelsL * this._canvasL.width / dbScaleBound);\n        this._amplitudeR = Math.floor(avgPowerDecibelsR * this._canvasR.width / dbScaleBound);\n      } else if (this._orientation === 'vertical') {\n        this._amplitudeL = Math.floor(avgPowerDecibelsL * this._canvasL.height / dbScaleBound);\n        this._amplitudeR = Math.floor(avgPowerDecibelsR * this._canvasR.height / dbScaleBound);\n      }\n      // Left channel\n      // Found a new max value (peak) [-this._dbScaleMin, 0] interval\n      if (this._peakL > this._amplitudeL) {\n        this._peakL = this._amplitudeL;\n        this._peakSetTimeL = this._audioCtx.currentTime;\n        // Update peak label\n        if (this._legend) {\n          avgPowerDecibelsL !== -Infinity ? this._dom.labels[0].textContent = _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].precisionRound(avgPowerDecibelsL, 1) : null;\n        }\n      } else if (this._audioCtx.currentTime - this._peakSetTimeL > 1) {\n        this._peakL = this._amplitudeL;\n        this._peakSetTimeL = this._audioCtx.currentTime;\n        // Update peak label\n        if (this._legend) {\n          avgPowerDecibelsL !== -Infinity ? this._dom.labels[0].textContent = _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].precisionRound(avgPowerDecibelsL, 1) : null;\n        }\n      }\n      // Right channel\n      // Found a new max value (peak) [-this._dbScaleMin, 0] interval\n      if (this._peakR > this._amplitudeR) {\n        this._peakR = this._amplitudeR;\n        this._peakSetTimeR = this._audioCtx.currentTime;\n        // Update peak label\n        if (this._legend) {\n          avgPowerDecibelsR !== -Infinity ? this._dom.labels[1].textContent = _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].precisionRound(avgPowerDecibelsR, 1) : null;\n        }\n      } else if (this._audioCtx.currentTime - this._peakSetTimeR > 1) {\n        this._peakR = this._amplitudeL;\n        this._peakSetTimeR = this._audioCtx.currentTime;\n        // Update peak label\n        if (this._legend) {\n          avgPowerDecibelsR !== -Infinity ? this._dom.labels[1].textContent = _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].precisionRound(avgPowerDecibelsR, 1) : null;\n        }\n      }\n      // Draw left and right peak meters\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawPeakMeter(this._canvasL, {\n        amplitude: this._amplitudeL,\n        peak: this._peakL,\n        orientation: this._orientation,\n        colors: this._peakGradient\n      });\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawPeakMeter(this._canvasR, {\n        amplitude: this._amplitudeR,\n        peak: this._peakR,\n        orientation: this._orientation,\n        colors: this._peakGradient\n      });\n    }\n\n    /** @method\r\n     * @name _createScaleTicks\r\n     * @private\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Build the scale tick depending on component orientation.</blockquote> **/\n  }, {\n    key: \"_createScaleTicks\",\n    value: function _createScaleTicks() {\n      var numTicks = Math.floor(this._dbScaleMin / this._dbScaleTicks);\n      var dbTickLabel = 0;\n      this._dom.scaleContainer.innerHTML = '';\n      if (this._orientation === 'horizontal') {\n        var tickWidth = this._canvasL.width / numTicks;\n        for (var i = 0; i < numTicks; ++i) {\n          var dbTick = document.createElement('DIV');\n          this._dom.scaleContainer.appendChild(dbTick);\n          dbTick.style.width = \"\".concat(tickWidth, \"px\");\n          dbTick.textContent = \"\".concat(dbTickLabel);\n          dbTickLabel -= this._dbScaleTicks;\n        }\n      } else {\n        var tickHeight = this._canvasL.height / numTicks;\n        for (var _i = 0; _i < numTicks; ++_i) {\n          var _dbTick = document.createElement('DIV');\n          this._dom.scaleContainer.appendChild(_dbTick);\n          _dbTick.style.height = \"\".concat(tickHeight, \"px\");\n          _dbTick.textContent = \"\".concat(dbTickLabel);\n          dbTickLabel -= this._dbScaleTicks;\n        }\n      }\n    }\n\n    /** @method\r\n     * @name _createPeakLabel\r\n     * @private\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Build the scale legend depending on component orientation.</blockquote> **/\n  }, {\n    key: \"_createPeakLabel\",\n    value: function _createPeakLabel() {\n      if (this._dom.labels.length === 2) {\n        this._dom.container.removeChild(this._dom.labels[0]);\n        this._dom.container.removeChild(this._dom.labels[1]);\n        this._dom.labels = [];\n      }\n      var peakLabelL = document.createElement('DIV');\n      var peakLabelR = document.createElement('DIV');\n      peakLabelL.classList.add('peak-value-container');\n      peakLabelR.classList.add('peak-value-container');\n      peakLabelL.textContent = '-∞';\n      peakLabelR.textContent = '-∞';\n      if (this._orientation === 'horizontal') {\n        peakLabelL.style.width = '28px';\n        peakLabelL.style.height = \"\".concat(this._canvasL.height + 2, \"px\"); // 2 px borders\n        peakLabelL.style.top = '14px';\n        peakLabelR.style.width = '28px';\n        peakLabelR.style.height = \"\".concat(this._canvasL.height + 2, \"px\"); // 2 px borders\n        peakLabelR.style.top = \"\".concat(this._canvasL.height + 16, \"px\"); // 2px borders + 14px height\n      } else {\n        peakLabelL.style.width = \"\".concat(this._canvasL.width + 2, \"px\"); // 2 px borders\n        peakLabelL.style.left = '18px';\n        peakLabelR.style.width = \"\".concat(this._canvasL.width + 2, \"px\"); // 2 px borders\n        peakLabelR.style.left = \"\".concat(this._canvasL.width + 20, \"px\"); // 2px borders + 18px width\n      }\n      this._dom.labels.push(peakLabelL);\n      this._dom.labels.push(peakLabelR);\n      this._dom.container.appendChild(this._dom.labels[0]);\n      this._dom.container.appendChild(this._dom.labels[1]);\n    }\n\n    /** @method\r\n     * @name _updateDimensions\r\n     * @private\r\n     * @memberof PeakMeter\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Usually called on resize event, update canvas dimension to fit render to DOM object.</blockquote> **/\n  }, {\n    key: \"_updateDimensions\",\n    value: function _updateDimensions() {\n      var widthOffset = 0;\n      var heightOffset = 0;\n      if (this._orientation === 'horizontal') {\n        if (this._legend) {\n          widthOffset = 30;\n          heightOffset = 14;\n        }\n        this._canvasL.width = this._renderTo.offsetWidth - widthOffset; // 2px borders + 28 px with for label\n\n        if (this._merged === true) {\n          this._canvasL.height = this._renderTo.offsetHeight - heightOffset - 2; // 2px border + scale height 14px\n          this._canvasR.height = this._renderTo.offsetHeight - heightOffset - 2; // 2px border + scale height 14px\n        } else {\n          this._canvasR.width = this._renderTo.offsetWidth - widthOffset; // 2px borders + 28 px with for label\n          this._canvasL.height = (this._renderTo.offsetHeight - heightOffset) / 2 - 2; // 2px border + scale height 14px\n          this._canvasR.height = (this._renderTo.offsetHeight - heightOffset) / 2 - 2; // 2px border + scale height 14px\n        }\n        if (this._legend) {\n          this._dom.scaleContainer.style.width = \"\".concat(this._canvasL.width, \"px\");\n        }\n      } else if (this._orientation === 'vertical') {\n        if (this._legend) {\n          widthOffset = 18;\n          heightOffset = 16;\n        } else {\n          this._canvasL.style.left = '0'; // Remove left offset for legend\n        }\n        this._canvasL.height = this._renderTo.offsetHeight - heightOffset - 2; // 2px borders + 16px height for label\n\n        if (this._merged === true) {\n          this._canvasL.width = this._renderTo.offsetWidth - widthOffset - 2; // 2px border + scale width 18px\n          this._canvasR.width = this._renderTo.offsetWidth - widthOffset - 2; // 2px border + scale width 18px\n        } else {\n          this._canvasR.height = this._renderTo.offsetHeight - heightOffset - 2; // 2px borders + 16px height for label\n          this._canvasL.width = (this._renderTo.offsetWidth - widthOffset) / 2 - 2; // 2px border + scale width 18px\n          this._canvasR.width = (this._renderTo.offsetWidth - widthOffset) / 2 - 2; // 2px border + scale width 18px\n        }\n        if (this._legend) {\n          this._dom.scaleContainer.style.height = \"\".concat(this._canvasL.height, \"px\");\n          this._dom.scaleContainer.style.width = '18px';\n        }\n      }\n    }\n  }]);\n}(_utils_VisuComponentStereo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PeakMeter);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/components/PeakMeter.js?");

/***/ }),

/***/ "./src/js/components/Spectrum.js":
/*!***************************************!*\
  !*** ./src/js/components/Spectrum.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_VisuComponentStereo_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/VisuComponentStereo.js */ \"./src/js/utils/VisuComponentStereo.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar Spectrum = /*#__PURE__*/function (_VisuComponentStereo) {\n  /** @summary Spectrum displays real time audio frequencies as vertical bars that scroll over time\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments VisuComponentStereo\r\n   * @description <blockquote>.</blockquote>\r\n   * @param {object} options - The spectrum options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {boolean} [options.merged=false] - Merge left and right channel into one output\r\n   * @param {boolean} [options.scale=false] - The peak meter legend\r\n   * @param {boolean} [options.colorSmoothing=false] - Display color intensity with a gradient to next sample value **/\n  function Spectrum(options) {\n    var _this;\n    _classCallCheck(this, Spectrum);\n    _this = _callSuper(this, Spectrum, [options]);\n    _this._updateDimensions();\n    _this._createLogarithmicScaleHeights();\n    // Update canvas CSS background color\n    var bgColor = 'black';\n    if (_this._merged === true) {\n      _this._canvasL.style.backgroundColor = bgColor;\n    } else {\n      _this._canvasL.style.backgroundColor = bgColor;\n      _this._canvasR.style.backgroundColor = bgColor;\n    }\n    return _this;\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  -------------------------------------  VISUCOMPONENTSTEREO OVERRIDES  ----------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof Spectrum\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The spectrum options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {boolean} [options.scale=false] - The peak meter legend\r\n   * @param {boolean} [options.colorSmoothing=false] - Display color intensity with a gradient to next sample value **/\n  _inherits(Spectrum, _VisuComponentStereo);\n  return _createClass(Spectrum, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      _superPropGet(Spectrum, \"_fillAttributes\", this, 3)([options]);\n      // Spectrum specific attributes\n      this._scaleType = options.scale || 'linear';\n      this._colorSmoothing = options.colorSmoothing || false;\n      this._canvasSpeed = 1; // Canvas offset per bin\n      // Used to animate canvas on audio bins analysis\n      this._bufferCanvas = null;\n      this._bufferCtx = null;\n      // Display utils\n      this._dom.settings = null;\n      this._dom.settingsPanel = null;\n      this._dimension = {\n        height: null,\n        canvasHeight: null,\n        width: null\n      };\n      this._logScale = [];\n      // Event binding\n      this._settingsClicked = this._settingsClicked.bind(this);\n      this._clickedElsewhere = this._clickedElsewhere.bind(this);\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @override\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create and configure canvas then append it to given DOM element.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      var _this2 = this;\n      _superPropGet(Spectrum, \"_buildUI\", this, 3)([]);\n      this._bufferCanvas = document.createElement('CANVAS');\n      this._bufferCtx = this._bufferCanvas.getContext('2d');\n      if (this._merged === true) {\n        this._dom.container.removeChild(this._canvasR);\n      }\n      // Update canvas dimensions\n      this._canvasL.width = this._dimension.width;\n      this._canvasL.height = this._dimension.canvasHeight;\n      this._canvasR.width = this._dimension.width;\n      this._canvasR.height = this._dimension.canvasHeight;\n      this._bufferCanvas.width = this._dimension.width;\n      this._bufferCanvas.height = this._dimension.canvasHeight;\n      // Create option button\n      var parser = new DOMParser();\n      this._dom.settings = parser.parseFromString(\"<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M24 13.616v-3.232c-1.651-.587-2.694-.752-3.219-2.019v-.001c-.527-1.271.1-2.134.847-3.707l-2.285-2.285c-1.561.742-2.433 1.375-3.707.847h-.001c-1.269-.526-1.435-1.576-2.019-3.219h-3.232c-.582 1.635-.749 2.692-2.019 3.219h-.001c-1.271.528-2.132-.098-3.707-.847l-2.285 2.285c.745 1.568 1.375 2.434.847 3.707-.527 1.271-1.584 1.438-3.219 2.02v3.232c1.632.58 2.692.749 3.219 2.019.53 1.282-.114 2.166-.847 3.707l2.285 2.286c1.562-.743 2.434-1.375 3.707-.847h.001c1.27.526 1.436 1.579 2.019 3.219h3.232c.582-1.636.75-2.69 2.027-3.222h.001c1.262-.524 2.12.101 3.698.851l2.285-2.286c-.744-1.563-1.375-2.433-.848-3.706.527-1.271 1.588-1.44 3.221-2.021zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z\\\"/></svg>\", 'image/svg+xml').documentElement;\n      this._dom.settings.classList.add('audio-spectrum-settings');\n      this._dom.settingsPanel = document.createElement('DIV');\n      this._dom.settingsPanel.classList.add('audio-spectrum-settings-panel');\n      this._dom.settingsPanel.innerHTML = \"\\n      <h3>Settings</h3>\\n      <form>\\n        <p class=\\\"legend\\\">Scale:</p>\\n        <label for=\\\"linear\\\">Linear</label>\\n        <input type=\\\"radio\\\" id=\\\"id-linear\\\" name=\\\"scale\\\" value=\\\"linear\\\" \".concat(this._scaleType === 'linear' ? 'checked' : '', \">\\n        <label for=\\\"logarithmic\\\">Logarithmic</label>\\n        <input type=\\\"radio\\\" id=\\\"id-logarithmic\\\" name=\\\"scale\\\" value=\\\"logarithmic\\\" \").concat(this._scaleType === 'logarithmic' ? 'checked' : '', \">\\n        <p class=\\\"smooth-color\\\">\\n          <label for=\\\"smoothColor\\\">Smooth colors</label>\\n          <input type=\\\"checkbox\\\" id=\\\"smoothColor\\\" name=\\\"smoothColor\\\" \").concat(this._colorSmoothing ? 'checked' : '', \">\\n        </p>\\n      </form>\\n    \");\n      var form = this._dom.settingsPanel.querySelector('form');\n      form.addEventListener('change', function (event) {\n        event.preventDefault(); // Prevent location redirection with params\n        var data = new FormData(form);\n        var output = [];\n        // Iterate over radios to extract values\n        var _iterator = _createForOfIteratorHelper(data),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var entry = _step.value;\n            output.push(entry[1]);\n          }\n          // Update canvas scale\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        _this2._scaleType = output[0];\n        // Set color smoothing from checkbox\n        _this2._colorSmoothing = output[1] === 'on';\n      }, false);\n      // Add display canvas to renderTo parent\n      this._dom.container.appendChild(this._dom.settingsPanel); // Append panel before to emulate z-index under settings button w/ no scss rules of z-index\n      this._dom.container.appendChild(this._dom.settings);\n      this._dom.settings.addEventListener('click', this._settingsClicked, false);\n    }\n\n    /** @method\r\n     * @name _removeEvents\r\n     * @private\r\n     * @override\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Add component events (resize, play, pause, dbclick).</blockquote> **/\n  }, {\n    key: \"_removeEvents\",\n    value: function _removeEvents() {\n      _superPropGet(Spectrum, \"_removeEvents\", this, 3)([]);\n      document.body.removeEventListener('click', this._clickedElsewhere, false);\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @override\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      _superPropGet(Spectrum, \"_onResize\", this, 3)([]);\n      this._updateDimensions();\n      this._createLogarithmicScaleHeights();\n      // Update canvas dimensions\n      this._canvasL.width = this._dimension.width;\n      this._canvasL.height = this._dimension.canvasHeight;\n      if (this._merged === false) {\n        this._canvasR.width = this._dimension.width;\n        this._canvasR.height = this._dimension.canvasHeight;\n      }\n      this._bufferCanvas.width = this._dimension.width;\n      this._bufferCanvas.height = this._dimension.canvasHeight;\n    }\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @override\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Real time method called by WebAudioAPI to process PCM data. Here we make a 8 bit frequency\r\n     * and time analysis.</blockquote> **/\n  }, {\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      if (this._isPlaying === true) {\n        if (this._merged === true) {\n          this._mergedStereoAnalysis();\n        } else {\n          this._stereoAnalysis();\n        }\n        requestAnimationFrame(this._processAudioBin);\n      }\n    }\n\n    /*  ----------  Spectrum internal methods  ----------  */\n\n    /** @method\r\n     * @name _mergedStereoAnalysis\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform a merged Left and Right analysis with 32 bit time domain data.</blockquote> **/\n  }, {\n    key: \"_mergedStereoAnalysis\",\n    value: function _mergedStereoAnalysis() {\n      var frequencies = new Uint8Array(this._nodes.analyser.frequencyBinCount);\n      this._nodes.analyser.getByteFrequencyData(frequencies);\n      this._drawSpectrogramForFrequencyBin(this._canvasL, frequencies);\n    }\n\n    /** @method\r\n     * @name _stereoAnalysis\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform a separated Left and Right analysis with 32 bit time domain data.</blockquote> **/\n  }, {\n    key: \"_stereoAnalysis\",\n    value: function _stereoAnalysis() {\n      var frequenciesL = new Uint8Array(this._nodes.analyserL.frequencyBinCount);\n      var frequenciesR = new Uint8Array(this._nodes.analyserR.frequencyBinCount);\n      this._nodes.analyserL.getByteFrequencyData(frequenciesL);\n      this._nodes.analyserR.getByteFrequencyData(frequenciesR);\n      this._drawSpectrogramForFrequencyBin(this._canvasL, frequenciesL);\n      this._drawSpectrogramForFrequencyBin(this._canvasR, frequenciesR);\n    }\n\n    /** @method\r\n     * @name _updateDimensions\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Usually called on resize event, update canvas dimension to fit render to DOM object.</blockquote> **/\n  }, {\n    key: \"_updateDimensions\",\n    value: function _updateDimensions() {\n      this._dimension.width = this._renderTo.offsetWidth - 2; // 2px borders\n\n      if (this._merged === true) {\n        this._dimension.height = this._renderTo.offsetHeight - 2; // 2px borders\n        this._dimension.canvasHeight = this._dimension.height;\n      } else {\n        this._dimension.height = this._renderTo.offsetHeight - 4; // 2px borders times two channels\n        this._dimension.canvasHeight = this._dimension.height / 2;\n      }\n    }\n\n    /** @method\r\n     * @name _settingsClicked\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Spectrum settings button callback.</blockquote> **/\n  }, {\n    key: \"_settingsClicked\",\n    value: function _settingsClicked() {\n      var opened = this._dom.settingsPanel.classList.contains('opened');\n      if (opened === false) {\n        // If opened, settings closure will be handled in clickedElsewhere\n        this._dom.settings.classList.add('opened');\n        this._dom.settingsPanel.classList.add('opened');\n        document.body.addEventListener('click', this._clickedElsewhere, false);\n      }\n    }\n\n    /** @method\r\n     * @name _clickedElsewhere\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Callback when a clicked is detected and settings context is open.</blockquote>\r\n     * @param {object} event - The click event **/\n  }, {\n    key: \"_clickedElsewhere\",\n    value: function _clickedElsewhere(event) {\n      if (!event.target.closest('.audio-spectrum-settings') && !event.target.closest('.audio-spectrum-settings-panel')) {\n        this._dom.settings.classList.remove('opened');\n        this._dom.settingsPanel.classList.remove('opened');\n        document.body.removeEventListener('click', this._clickedElsewhere, false);\n      }\n    }\n\n    /** @method\r\n     * @name _drawSpectrogramForFrequencyBin\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a vertical ray representing the audio frequencies at process time.</blockquote>\r\n     * @param {object} canvas - The canvas to draw spectrum ray into\r\n     * @param {Uint8Array} frequencies - The frequencies for a given audio bin **/\n  }, {\n    key: \"_drawSpectrogramForFrequencyBin\",\n    value: function _drawSpectrogramForFrequencyBin(canvas, frequencies) {\n      var ctx = canvas.getContext('2d');\n      // Copy previous image\n      this._bufferCtx.drawImage(canvas, 0, 0, this._dimension.width, this._dimension.canvasHeight);\n      // Array length is always (fftSize / 2)\n      for (var i = 0; i < frequencies.length; ++i) {\n        if (this._scaleType === 'linear') {\n          this._fillRectLinear(ctx, frequencies, i);\n        } else {\n          this._fillRectLogarithm(ctx, frequencies, i);\n        }\n      }\n      // Offset canvas to the left and paste stored image\n      ctx.translate(-this._canvasSpeed, 0);\n      ctx.drawImage(this._bufferCanvas, 0, 0, this._dimension.width, this._dimension.canvasHeight, 0, 0, this._dimension.width, this._dimension.canvasHeight);\n      ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset the transformation matrix\n    }\n\n    /** @method\r\n     * @name _drawSpectrogramForFrequencyBin\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw the vertical ray with a linear scale.</blockquote>\r\n     * @param {object} ctx - The canvas context\r\n     * @param {Uint8Array} frequencies - The frequencies for a given audio bin\r\n     * @param {number} i - The index to scale linearly **/\n  }, {\n    key: \"_fillRectLinear\",\n    value: function _fillRectLinear(ctx, frequencies, i) {\n      var scaledHeight = this._scaleLinearIndexToHeight(i);\n      var frequencyHeight = this._dimension.canvasHeight / frequencies.length;\n      if (i === 0 || !this._colorSmoothing) {\n        ctx.fillStyle = \"rgb(\".concat(frequencies[i], \", \").concat(frequencies[i], \", \").concat(frequencies[i], \")\");\n      } else {\n        var gradient = ctx.createLinearGradient(0, this._dimension.canvasHeight - scaledHeight - frequencyHeight,\n        // X0/Y0\n        0, this._dimension.canvasHeight - scaledHeight // X1/Y1\n        );\n        // Add color stops from current color to previous sample color\n        gradient.addColorStop(0, \"rgb(\".concat(frequencies[i], \", \").concat(frequencies[i], \", \").concat(frequencies[i], \")\"));\n        gradient.addColorStop(1, \"rgb(\".concat(frequencies[i - 1], \", \").concat(frequencies[i - 1], \", \").concat(frequencies[i - 1], \")\"));\n        ctx.fillStyle = gradient;\n      }\n      // Linear scale\n      ctx.fillRect(this._dimension.width - this._canvasSpeed,\n      // X pos\n      this._dimension.canvasHeight - scaledHeight - frequencyHeight,\n      // Y pos\n      this._canvasSpeed,\n      // Width is speed value\n      frequencyHeight // Height depends on canvas height\n      );\n    }\n\n    /** @method\r\n     * @name _drawSpectrogramForFrequencyBin\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw the vertical ray with a logarithm scale.</blockquote>\r\n     * @param {object} ctx - The canvas context\r\n     * @param {Uint8Array} frequencies - The frequencies for a given audio bin\r\n     * @param {number} i - The index to scale logarithmically **/\n  }, {\n    key: \"_fillRectLogarithm\",\n    value: function _fillRectLogarithm(ctx, frequencies, i) {\n      if (i === 0 || i === frequencies.length - 1 || !this._colorSmoothing) {\n        ctx.fillStyle = \"rgb(\".concat(frequencies[i], \", \").concat(frequencies[i], \", \").concat(frequencies[i], \")\");\n      } else {\n        var gradient = ctx.createLinearGradient(0, this._logScale[i],\n        // X0/Y0\n        0, this._logScale[i - 1] // X1/Y1\n        );\n        // Add color stops from current color to previous sample color\n        gradient.addColorStop(0, \"rgb(\".concat(frequencies[i], \", \").concat(frequencies[i], \", \").concat(frequencies[i], \")\"));\n        gradient.addColorStop(1, \"rgb(\".concat(frequencies[i - 1], \", \").concat(frequencies[i - 1], \", \").concat(frequencies[i - 1], \")\"));\n        ctx.fillStyle = gradient;\n      }\n      // Log scale\n      ctx.fillRect(this._dimension.width - this._canvasSpeed,\n      // X pos\n      this._logScale[i - 1],\n      // Y pos\n      this._canvasSpeed,\n      // Width is speed value\n      this._logScale[i] - this._logScale[i - 1] // Height is computed with previous sample offset\n      );\n    }\n\n    /** @method\r\n     * @name _scaleLinearIndexToHeight\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Convert linear value to logarithmic value.</blockquote>\r\n     * @param {number} index - The canvas context **/\n  }, {\n    key: \"_scaleLinearIndexToHeight\",\n    value: function _scaleLinearIndexToHeight(index) {\n      // Convert a range to another, maintaining ratio\n      // oldRange = (oldMax - oldMin)\n      // newRange = (newMax - newMin)\n      // newValue = (((oldValue - oldMin) * newRange) / oldRange) + NewMin */\n      // Convert from [0, (this._fftSize / 2)] to [0, this._dimension.canvasHeight] (frequency array length scale to canvas height scale)\n      var oldRange = this._fftSize / 2;\n      var newRange = this._dimension.canvasHeight;\n      return index * newRange / oldRange;\n    }\n\n    /** @method\r\n     * @name _createLogarithmicScaleHeights\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Pre-compute samples height on a logarithmic scale to avoid computation on render process.</blockquote> **/\n  }, {\n    key: \"_createLogarithmicScaleHeights\",\n    value: function _createLogarithmicScaleHeights() {\n      var _this3 = this;\n      return new Promise(function (resolve) {\n        _this3._logScale = [_this3._dimension.canvasHeight]; // Reset previously made scale\n        for (var i = 1; i < _this3._fftSize / 2; ++i) {\n          // Log(0) forbidden, we offset\n          _this3._logScale.push(_this3._computeLogSampleHeight(i)); // For each frequency sample, compute its log height offset from origin\n        }\n        resolve();\n      });\n    }\n\n    /** @method\r\n     * @name _computeLogSampleHeight\r\n     * @private\r\n     * @memberof Spectrum\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Compute log sample height in canvas.</blockquote>\r\n     * @param {number} sample - The sample to compute its log height **/\n  }, {\n    key: \"_computeLogSampleHeight\",\n    value: function _computeLogSampleHeight(sample) {\n      return this._dimension.canvasHeight - Math.log(sample) / Math.log(10) / (Math.log(this._fftSize / 2) / Math.log(10)) * this._dimension.canvasHeight;\n    }\n  }]);\n}(_utils_VisuComponentStereo_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Spectrum);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/components/Spectrum.js?");

/***/ }),

/***/ "./src/js/components/Timeline.js":
/*!***************************************!*\
  !*** ./src/js/components/Timeline.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/VisuComponentMono.js */ \"./src/js/utils/VisuComponentMono.js\");\n/* harmony import */ var _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/CanvasUtils.js */ \"./src/js/utils/CanvasUtils.js\");\n/* harmony import */ var _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ColorUtils.js */ \"./src/js/utils/ColorUtils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar MAX_CANVAS_WIDTH = 32000;\nvar Timeline = /*#__PURE__*/function (_VisuComponentMono) {\n  /** @summary Timeline displays a scrolling audio waveform.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments VisuComponentMono\r\n   * @description <blockquote>Will display a waveform that scrolls over playback. If provided, BPM is visualised as\r\n   * vertical bars with emphasis on main beats according to time signature. It is interactive and will update the player's\r\n   * current time value to match the dragged one. This class extends VisuComponentMono only because it performs an offline\r\n   * analysis on audio and the stereo information are already held in audio buffer.</blockquote>\r\n   * @param {object} options - The timeline options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {object} [options.beat=null] - The beat configuration\r\n   * @param {object} [options.beat.offset=null] - offset before first beat\r\n   * @param {object} [options.beat.bpm=null] - The track bpm\r\n   * @param {object} [options.beat.timeSignature=null] - The track time signature to put emphasis on main beats\r\n   * @param {object} [options.wave] - The wave options\r\n   * @param {object} [options.wave.align='center'] - The alignment of the wave, can be either 'top', 'center' or 'bottom'\r\n   * @param {object} [options.colors] - Timeline color potions\r\n   * @param {object} [options.colors.background='#1D1E25'] - Canvas background color in Hex/RGB/HSL\r\n   * @param {object} [options.colors.track='#12B31D'] - The timeline color in Hex/RGB/HSL\r\n   * @param {object} [options.colors.mainBeat='#56D45B'] - The main beat triangles color in Hex/RGB/HSL\r\n   * @param {object} [options.colors.subBeat='#FF6B67'] - The sub beat triangles color in Hex/RGB/HSL\r\n   * @param {object[]} [options.hotCues=[]] - Hotcues sorted array to load waveform with. Each array item must contain a time key with its value **/\n  function Timeline(options) {\n    var _this;\n    _classCallCheck(this, Timeline);\n    _this = _callSuper(this, Timeline, [options]);\n    _this._colors = {\n      background: options.colors ? options.colors.background || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor,\n      track: options.colors ? options.colors.track || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultDarkPrimaryColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultDarkPrimaryColor,\n      mainBeat: options.colors ? options.colors.mainBeat || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultPrimaryColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultPrimaryColor,\n      subBeat: options.colors ? options.colors.subBeat || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultAntiPrimaryColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultAntiPrimaryColor,\n      loop: options.colors ? options.colors.loop || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLoopColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLoopColor,\n      loopAlpha: options.colors ? options.colors.loopAlpha || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLoopAlphaColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultLoopAlphaColor\n    };\n    _this._canvas.style.backgroundColor = _this._colors.background;\n    _this._canvasSpeed = options.speed ? options.speed : 5.0; // Time in seconds\n\n    _this._beat = {\n      offset: options.beat ? options.beat.offset : null,\n      bpm: options.beat ? options.beat.bpm : null,\n      timeSignature: options.beat ? options.beat.timeSignature : null\n    };\n    _this._wave = {\n      align: options.wave ? options.wave.align || 'center' : 'center',\n      scale: options.wave ? options.wave.scale || .95 : .95\n    };\n    // HotCues and beats arrays\n    _this._hotCues = _toConsumableArray(options.hotCues);\n    _this._beatsArray = [];\n    _this._beatCount = '0.0';\n    // Loop utils\n    _this._loopEntry = null;\n    _this._loopEnd = null;\n    _this._loopBuffer = null;\n    _this._isLooping = false;\n    _this._loopStartedAt = 0;\n    _this._playerPausedAt = 0;\n    _this._audioBuffer = null; // Store audio buffer to avoid multiple loading of file during loop process\n    // Offline canvas -> main canvas is divided with 32k px wide canvases\n    _this._canvases = [];\n    _this._cueCanvases = [];\n    _this._beatCanvases = [];\n    _this._loopCanvases = [];\n    // Drag canvas utils\n    _this._isDragging = false;\n    _this._wasPlaying = false;\n    _this._draggedTime = 0;\n    _this._startDrag = {\n      x: 0,\n      y: 0\n    };\n    if (_this._player.src !== '') {\n      _this._getPlayerSourceFile();\n    }\n    return _this;\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  --------------------------------------  VISUCOMPONENTMONO OVERRIDES  -----------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof Timeline\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The frequency circle options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one **/\n  _inherits(Timeline, _VisuComponentMono);\n  return _createClass(Timeline, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      _superPropGet(Timeline, \"_fillAttributes\", this, 3)([options]);\n      this._offlineCtx = null;\n      this._offlineBuffer = null;\n      // Local event binding\n      this._trackLoaded = this._trackLoaded.bind(this);\n      this._onProgress = this._onProgress.bind(this);\n      this._mouseDown = this._mouseDown.bind(this);\n      this._mouseMove = this._mouseMove.bind(this);\n      this._mouseUp = this._mouseUp.bind(this);\n    }\n\n    /** @method\r\n     * @name _addEvents\r\n     * @private\r\n     * @override\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Add component events (resize, play, pause, dbclick).</blockquote> **/\n  }, {\n    key: \"_addEvents\",\n    value: function _addEvents() {\n      if (this._noEvents === false) {\n        _superPropGet(Timeline, \"_addEvents\", this, 3)([]);\n        this._player.addEventListener('loadedmetadata', this._trackLoaded, false);\n        this._player.addEventListener('timeupdate', this._onProgress, false);\n        this._canvas.addEventListener('mousedown', this._mouseDown, false);\n        if (!this._player.paused) {\n          this._isPlaying = true;\n          requestAnimationFrame(this._processAudioBin);\n        }\n      }\n    }\n\n    /** @method\r\n     * @name _removeEvents\r\n     * @private\r\n     * @override\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Remove component events (resize, play, pause, dbclick).</blockquote> **/\n  }, {\n    key: \"_removeEvents\",\n    value: function _removeEvents() {\n      _superPropGet(Timeline, \"_removeEvents\", this, 3)([]);\n      this._player.removeEventListener('loadedmetadata', this._trackLoaded, false);\n      this._player.removeEventListener('timeupdate', this._onProgress, false);\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @override\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      _superPropGet(Timeline, \"_onResize\", this, 3)([]);\n      this._fillData();\n      this._clearCanvas();\n      this._drawTimeline(this._player.currentTime);\n    }\n  }, {\n    key: \"_clearCanvas\",\n    value: function _clearCanvas(clearBeat, clearHotCue, clearLoop) {\n      _superPropGet(Timeline, \"_clearCanvas\", this, 3)([]);\n      // Clear beat bars canvas\n      if (clearBeat) {\n        for (var i = 0; i < this._beatCanvases.length; ++i) {\n          this._beatCanvases[i].getContext('2d').clearRect(0, 0, this._beatCanvases[i].width, this._beatCanvases[i].height);\n        }\n      }\n      // Clear hot cue canvas\n      if (clearHotCue) {\n        for (var _i = 0; _i < this._cueCanvases.length; ++_i) {\n          this._cueCanvases[_i].getContext('2d').clearRect(0, 0, this._cueCanvases[_i].width, this._cueCanvases[_i].height);\n        }\n      }\n      // Clear loop canvas\n      if (clearLoop) {\n        for (var _i2 = 0; _i2 < this._loopCanvases.length; ++_i2) {\n          this._loopCanvases[_i2].getContext('2d').clearRect(0, 0, this._loopCanvases[_i2].width, this._loopCanvases[_i2].height);\n        }\n      }\n    }\n\n    /** @method\r\n     * @name _dblClick\r\n     * @private\r\n     * @override\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On double click event callback.</blockquote> **/\n  }, {\n    key: \"_dblClick\",\n    value: function _dblClick() {\n      // Required to revoke fullscreen toggle from parent class, as it interferes with drag feature\n    }\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @override\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Real time method called by WebAudioAPI to process PCM data. Here we make a 8 bit frequency\r\n     * and time analysis.</blockquote> **/\n  }, {\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      if (this._isPlaying === true || this._isLooping === true) {\n        // So UI keeps being update while player is virtually paused\n        if (this._isLooping === true) {\n          this._player.currentTime = this._loopEntry.time + (this._playerPausedAt + this._audioCtx.currentTime - this._loopStartedAt) % (this._loopEnd.time - this._loopEntry.time);\n        }\n        // Draw timeline and request new process in raf\n        this._clearCanvas();\n        this._drawTimeline(this._player.currentTime);\n        requestAnimationFrame(this._processAudioBin);\n      }\n    }\n\n    /*  ----------  Timeline internal methods  ----------  */\n  }, {\n    key: \"_startLoopSequence\",\n    value: function _startLoopSequence(immediateLoop) {\n      var _this2 = this;\n      if (immediateLoop) {\n        this._player.currentTime = this._loopEntry.time;\n      }\n      var workingBuffer = this._audioBuffer.slice();\n      this._audioCtx.decodeAudioData(workingBuffer, function (buffer) {\n        _this2._loopBuffer = _this2._audioCtx.createBufferSource();\n        _this2._loopBuffer.buffer = buffer;\n        _this2._loopBuffer.connect(_this2._audioCtx.destination);\n        _this2._loopBuffer.loop = true;\n        _this2._loopBuffer.loopStart = _this2._loopEntry.time;\n        _this2._loopBuffer.loopEnd = _this2._loopEnd.time;\n        _this2._loopBuffer.start(0, _this2._player.currentTime);\n        _this2._player.pause();\n        _this2._loopStartedAt = _this2._audioCtx.currentTime;\n        _this2._playerPausedAt = _this2._player.currentTime;\n        _this2._isLooping = true;\n        _this2._processAudioBin();\n      });\n    }\n\n    /** @method\r\n     * @name _trackLoaded\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Player callback on track loaded.</blockquote> **/\n  }, {\n    key: \"_trackLoaded\",\n    value: function _trackLoaded() {\n      cancelAnimationFrame(this._processAudioBin);\n      this._clearCanvas(); // Clear previous canvas\n      // Do XHR to request file and parse it\n      this._getPlayerSourceFile();\n    }\n\n    /** @method\r\n     * @name _onProgress\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On progress callback.</blockquote> **/\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress() {\n      this._clearCanvas();\n      this._drawTimeline(this._player.currentTime || 0);\n    }\n\n    /** @method\r\n     * @name _mouseDown\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Mouse down callback.</blockquote>\r\n     * @param {object} event - The mouse down event **/\n  }, {\n    key: \"_mouseDown\",\n    value: function _mouseDown(event) {\n      var rect = event.target.getBoundingClientRect();\n      // X coord must be relative to cuent canvas. Check half width to center coord, then add center position, module MAX_CANVAS_WIDTH\n      var x = (event.clientX - rect.left - this._canvas.width / 2 + this._player.currentTime / this._canvasSpeed * this._canvas.width) % MAX_CANVAS_WIDTH;\n      var y = event.clientY - rect.top;\n      var hotCue = this._hotCueClicked(x, y);\n      if (hotCue) {\n        this._player.currentTime = hotCue.time;\n        this._clearCanvas();\n        this._drawTimeline(this._player.currentTime);\n      } else {\n        this._isDragging = true;\n        this._startDrag.x = event.clientX;\n        this._startDrag.y = event.clientY;\n        // Save previous playback status and pause only if required\n        if (this._player.paused === false) {\n          this._wasPlaying = true;\n          this._player.pause();\n        }\n        // Subscribe to drag events\n        this._canvas.addEventListener('mousemove', this._mouseMove, false);\n        this._canvas.addEventListener('mouseup', this._mouseUp, false);\n        this._canvas.addEventListener('mouseout', this._mouseUp, false);\n      }\n    }\n\n    /** @method\r\n     * @name _mouseDown\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Mouse move callback.</blockquote>\r\n     * @param {object} event - The mouse move event **/\n  }, {\n    key: \"_mouseMove\",\n    value: function _mouseMove(event) {\n      // Only perform drag code if mouse down was previously fired\n      if (this._isDragging === true) {\n        var variation = this._startDrag.x - event.clientX;\n        var timeOffset = variation * this._canvasSpeed / this._canvas.width * 2;\n        this._draggedTime = this._player.currentTime + timeOffset;\n        this._clearCanvas();\n        this._drawTimeline(this._draggedTime);\n      }\n    }\n\n    /** @method\r\n     * @name _mouseUp\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Mouse up callback.</blockquote> **/\n  }, {\n    key: \"_mouseUp\",\n    value: function _mouseUp() {\n      this._isDragging = false;\n      this._startDrag.x = 0;\n      this._startDrag.y = 0;\n      this._player.currentTime = this._draggedTime || this._player.currentTime;\n      this._draggedTime = null;\n      // Restore playback status\n      if (this._wasPlaying === true) {\n        this._wasPlaying = false;\n        this._player.play();\n      }\n      // Remove drag events\n      this._canvas.removeEventListener('mousemove', this._mouseMove, false);\n      this._canvas.removeEventListener('mouseup', this._mouseUp, false);\n      this._canvas.removeEventListener('mouseout', this._mouseUp, false);\n    }\n\n    /** @method\r\n     * @name _processAudioFile\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform an offline analysis on whole track.</blockquote>\r\n     * @param {object} response - HTTP response for audio track to extract buffer from **/\n  }, {\n    key: \"_processAudioFile\",\n    value: function _processAudioFile(response) {\n      var _this3 = this;\n      this._audioBuffer = response.slice();\n      // Set offline context according to track duration to get its full samples\n      this._offlineCtx = new OfflineAudioContext(2, this._audioCtx.sampleRate * this._player.duration, this._audioCtx.sampleRate);\n      this._offlineSource = this._offlineCtx.createBufferSource();\n      this._audioCtx.decodeAudioData(response, function (buffer) {\n        _this3._offlineSource.buffer = buffer;\n        _this3._offlineSource.connect(_this3._offlineCtx.destination);\n        _this3._offlineSource.start();\n        _this3._offlineCtx.startRendering().then(function (renderedBuffer) {\n          _this3._offlineBuffer = renderedBuffer;\n          _this3._fillData();\n          _this3._drawTimeline(_this3._player.currentTime || 0);\n        })[\"catch\"](function (err) {\n          console.log('Rendering failed: ' + err);\n        });\n      });\n    }\n\n    /** @method\r\n     * @name _fillData\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Generate merged data from audio buffer.</blockquote> **/\n  }, {\n    key: \"_fillData\",\n    value: function _fillData() {\n      if (this._offlineBuffer) {\n        // Clear any previous canvas\n        this._canvases = [];\n        this._cueCanvases = [];\n        this._beatCanvases = [];\n        this._loopCanvases = [];\n        // Compute useful values\n        var data = this._genScaledMonoData(this._offlineBuffer);\n        var step = this._canvasSpeed * this._offlineBuffer.sampleRate / this._canvas.width;\n        var totalLength = Math.round(this._offlineBuffer.duration / this._canvasSpeed * this._canvas.width);\n        // Draw full track on offline canvas\n        for (var i = 0; i < totalLength; i += MAX_CANVAS_WIDTH) {\n          // Create canvas with width of the reduced-in-size buffer's length.\n          var canvas = document.createElement('CANVAS');\n          var ctx = canvas.getContext('2d');\n          var cueCanvas = document.createElement('CANVAS');\n          var beatCanvas = document.createElement('CANVAS');\n          var loopCanvas = document.createElement('CANVAS');\n          var width = totalLength - i;\n          width = width > MAX_CANVAS_WIDTH ? MAX_CANVAS_WIDTH : width;\n          // Update offline canvas dimension\n          canvas.width = width;\n          canvas.height = this._canvas.height;\n          cueCanvas.width = width;\n          cueCanvas.height = this._canvas.height;\n          beatCanvas.width = width;\n          beatCanvas.height = this._canvas.height;\n          loopCanvas.width = width;\n          loopCanvas.height = this._canvas.height;\n          // Clear offline context\n          ctx.clearRect(0, 0, totalLength, this._canvas.height);\n          // Draw the canvas\n          for (var j = 0; j < width; ++j) {\n            var offset = Math.floor((i + j) * step);\n            var max = 0.0; // The max value to draw\n            // Update maximum value in step range\n            for (var k = 0; k < step; ++k) {\n              if (data[offset + k] > max) {\n                max = data[offset + k];\n              }\n            }\n            // Set waveform color according to sample intensity\n            ctx.fillStyle = _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lightenDarkenColor(this._colors.track, max * 190); // 190, not 255 to avoid full white on sample at max value\n            // Update max to scale in half canvas height\n            max = Math.floor(max * (this._canvas.height * this._wave.scale));\n            if (this._wave.align === 'center') {\n              // Fill up and down side of timeline\n              ctx.fillRect(j, this._canvas.height / 2, 1, -(max / 2));\n              ctx.fillRect(j, this._canvas.height / 2, 1, max / 2);\n              // Add tiny centered line\n              ctx.fillRect(j, this._canvas.height / 2 - 0.5, 1, 1);\n            } else if (this._wave.align === 'top') {\n              ctx.fillRect(j, 1, 1, max);\n            } else if (this._wave.align === 'bottom') {\n              ctx.fillRect(j, this._canvas.height - 1, 1, -max);\n            }\n          }\n          // Store canvas to properly animate Timeline on progress\n          this._canvases.push(canvas);\n          this._cueCanvases.push(cueCanvas);\n          this._beatCanvases.push(beatCanvas);\n          this._loopCanvases.push(loopCanvas);\n        }\n        if (this._beat.bpm !== null && this._beat.offset !== null) {\n          this._fillBeatBars({\n            totalWidth: this._offlineBuffer.duration / this._canvasSpeed * this._canvas.width,\n            beatWidth: 1 / (this._beat.bpm / 60) / this._canvasSpeed * this._canvas.width,\n            beatOffset: this._beat.offset / this._canvasSpeed * this._canvas.width\n          });\n        }\n        this._drawHotCues(); // Load hot cues if any\n      }\n    }\n  }, {\n    key: \"_fillBeatBars\",\n    value: function _fillBeatBars(options) {\n      var beatOffset = options.beatOffset;\n      var canvasIndex = 0; // The offline canvas to consider\n      // We floor because last beat is pretty irrelevant\n      for (var i = 0; i < Math.floor(options.totalWidth / options.beatWidth); ++i) {\n        // We reached MAX_CANVAS_WIDTH, using next offline canvas\n        if (i * options.beatWidth + beatOffset >= MAX_CANVAS_WIDTH + canvasIndex * MAX_CANVAS_WIDTH) {\n          // Increment offline canvas to use\n          ++canvasIndex;\n          // When changing canvas, the beatOffset is dependant to last beat saved position.\n          for (var j = 1; j < canvasIndex; ++i) {\n            // We iterate for each canvas, and sums the offset per canvas so they cumulates\n            beatOffset += options.beatWidth - (MAX_CANVAS_WIDTH * j - this._beatsArray[this._beatsArray.length - 1].xPos % (MAX_CANVAS_WIDTH * j));\n          }\n        }\n        // Draw beat bar, x position is loop index times a space between beats, plus the beat offset,\n        // modulo max canvas width to fit in offline canvases\n        this._drawBeatBar(i, i * options.beatWidth + beatOffset, canvasIndex);\n      }\n    }\n\n    /** @method\r\n     * @name _drawBeatBar\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a beat bar with its triangle with color that depends on main beat or sub beat.</blockquote>\r\n     * @param {object} beatCount - The beat number from first\r\n     * @param {object} canvas - The canvas to draw in\r\n     * @param {object} ctx - The associated context\r\n     * @param {number} j - The y value **/\n  }, {\n    key: \"_drawBeatBar\",\n    value: function _drawBeatBar(beatCount, x, canvasIndex) {\n      var canvas = this._beatCanvases[canvasIndex];\n      var ctx = canvas.getContext('2d');\n      // Determine beat bar color\n      if (beatCount % this._beat.timeSignature === 0) {\n        ctx.fillStyle = 'white';\n      } else {\n        ctx.fillStyle = 'grey';\n      }\n      // Beat bar drawing\n      ctx.fillRect(x % MAX_CANVAS_WIDTH, 9, 1, this._canvas.height - 18);\n      // Determine beat triangle color\n      if (beatCount % this._beat.timeSignature === 0) {\n        ctx.fillStyle = this._colors.mainBeat;\n      } else {\n        ctx.fillStyle = this._colors.subBeat;\n      }\n      // Upper triangle\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawTriangle(canvas, {\n        x: x % MAX_CANVAS_WIDTH,\n        y: 1,\n        radius: 6,\n        top: 10\n      });\n      // Down triangle\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawTriangle(canvas, {\n        x: x % MAX_CANVAS_WIDTH,\n        y: this._canvas.height - 1,\n        radius: 6,\n        top: this._canvas.height - 10\n      });\n      // Update beats array with new beat bar\n      this._beatsArray.push({\n        primaryBeat: beatCount % this._beat.timeSignature === 0,\n        beatCount: beatCount,\n        xPos: x,\n        time: x * this._canvasSpeed / this._canvas.width,\n        canvasIndex: canvasIndex\n      });\n    }\n\n    /** @method\r\n     * @name _genScaledMonoData\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Merged L/R Sub sample channel data to compute average value, depending on bar count.</blockquote>\r\n     * @param {object} buffer - Audio buffer\r\n     * @return {number[]} Array of height per sub samples **/\n  }, {\n    key: \"_genScaledMonoData\",\n    value: function _genScaledMonoData(buffer) {\n      var dataL = buffer.getChannelData(0);\n      var dataR = buffer.getChannelData(1);\n      var output = [];\n      for (var i = 0; i < dataL.length; ++i) {\n        output.push((Math.abs(dataL[i]) + Math.abs(dataR[i])) / 2);\n      }\n      return output;\n    }\n\n    /** @method\r\n     * @name _drawTimeline\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw timeline with a given progress.</blockquote>\r\n     * @param {number} time - Track current time **/\n  }, {\n    key: \"_drawTimeline\",\n    value: function _drawTimeline(time) {\n      var center = Math.floor(time * this._canvas.width / this._canvasSpeed);\n      var leftEdgeIndex = Math.floor((center - this._canvas.width / 2) / MAX_CANVAS_WIDTH);\n      if (leftEdgeIndex < 0) {\n        leftEdgeIndex = 0;\n      }\n      var rightEdgeIndex = Math.floor((center + this._canvas.width / 2) / MAX_CANVAS_WIDTH);\n      if (rightEdgeIndex >= this._canvases.length) {\n        rightEdgeIndex = this._canvases.length - 1;\n      }\n      for (var i = leftEdgeIndex; i <= rightEdgeIndex; ++i) {\n        this._ctx.drawImage(this._canvases[i], this._canvas.width / 2 - center + MAX_CANVAS_WIDTH * i, 0);\n        this._ctx.drawImage(this._beatCanvases[i], this._canvas.width / 2 - center + MAX_CANVAS_WIDTH * i, 0);\n        this._ctx.drawImage(this._cueCanvases[i], this._canvas.width / 2 - center + MAX_CANVAS_WIDTH * i, 0);\n        this._ctx.drawImage(this._loopCanvases[i], this._canvas.width / 2 - center + MAX_CANVAS_WIDTH * i, 0);\n      }\n      // Draw centered vertical bar\n      this._ctx.fillStyle = _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultAntiPrimaryColor;\n      this._ctx.fillRect(this._canvas.width / 2, 1, 3, this._canvas.height - 2);\n      this._ctx.strokeStyle = 'black';\n      this._ctx.lineWidth = 1;\n      this._ctx.strokeRect(this._canvas.width / 2, 1, 3, this._canvas.height - 2);\n      // Draw beat count next to centered line\n      if (this._beatsArray.length > 0) {\n        var label = '0.0';\n        for (var _i3 = 0; _i3 < this._beatsArray.length; ++_i3) {\n          if (time <= this._beatsArray[_i3].time) {\n            var measureCount = Math.floor((this._beatsArray[_i3].beatCount - 1) / this._beat.timeSignature) + 1;\n            var timeCount = (this._beatsArray[_i3].beatCount - 1) % this._beat.timeSignature;\n            label = \"\".concat(measureCount, \".\").concat(timeCount === -1 ? 1 : timeCount + 1);\n            break;\n          }\n        }\n        var top = 14;\n        if (this._wave.align === 'top') {\n          top = this._canvas.height - 4;\n        }\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawBeatCount(this._canvas, {\n          label: label,\n          x: this._canvas.width / 2 + 8,\n          y: top\n        });\n      }\n    }\n  }, {\n    key: \"_drawHotCues\",\n    value: function _drawHotCues() {\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        this._drawHotCue(this._hotCues[i]);\n      }\n    }\n  }, {\n    key: \"_drawHotCue\",\n    value: function _drawHotCue(hotCue) {\n      var top = 2;\n      if (this._wave.align === 'top') {\n        top = this._canvas.height - 20;\n      }\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawHotCue(this._cueCanvases[hotCue.canvasIndex], {\n        x: hotCue.xPos - hotCue.canvasIndex * MAX_CANVAS_WIDTH + 18 / 2,\n        y: top,\n        size: 18,\n        label: hotCue.label || hotCue.number,\n        color: hotCue.color\n      });\n    }\n  }, {\n    key: \"_hotCueClicked\",\n    value: function _hotCueClicked(x, y) {\n      if (y > 2 && y < 20) {\n        for (var i = 0; i < this._hotCues.length; ++i) {\n          var xPos = this._hotCues[i].xPos - this._hotCues[i].canvasIndex * MAX_CANVAS_WIDTH;\n          if (x > xPos && x < xPos + 18) {\n            return this._hotCues[i];\n          }\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"_drawLoop\",\n    value: function _drawLoop() {\n      if (this._loopEntry) {\n        var ctx = this._loopCanvases[this._loopEntry.canvasIndex].getContext('2d');\n        ctx.fillStyle = this._colors.loop;\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawTriangle(this._loopCanvases[this._loopEntry.canvasIndex], {\n          x: this._loopEntry.xPos % MAX_CANVAS_WIDTH + 1,\n          y: 1,\n          radius: 9,\n          top: 14\n        });\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawTriangle(this._loopCanvases[this._loopEntry.canvasIndex], {\n          x: this._loopEntry.xPos % MAX_CANVAS_WIDTH + 1,\n          y: this._loopCanvases[this._loopEntry.canvasIndex].height - 1,\n          radius: 9,\n          top: this._loopCanvases[this._loopEntry.canvasIndex].height - 14\n        });\n      }\n      if (this._loopEnd) {\n        var _ctx = this._loopCanvases[this._loopEntry.canvasIndex].getContext('2d');\n        _ctx.fillStyle = this._colors.loop;\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawTriangle(this._loopCanvases[this._loopEnd.canvasIndex], {\n          x: this._loopEnd.xPos % MAX_CANVAS_WIDTH + 1,\n          y: 1,\n          radius: 9,\n          top: 14\n        });\n        _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawTriangle(this._loopCanvases[this._loopEnd.canvasIndex], {\n          x: this._loopEnd.xPos % MAX_CANVAS_WIDTH + 1,\n          y: this._loopCanvases[this._loopEnd.canvasIndex].height - 1,\n          radius: 9,\n          top: this._loopCanvases[this._loopEnd.canvasIndex].height - 14\n        });\n      }\n      if (this._loopEntry && this._loopEnd) {\n        var _ctx2 = this._loopCanvases[this._loopEntry.canvasIndex].getContext('2d');\n        _ctx2.fillStyle = this._colors.loopAlpha;\n        if (this._loopEntry.canvasIndex === this._loopEnd.canvasIndex) {\n          _ctx2.fillRect(this._loopEntry.xPos, 30, this._loopEnd.xPos - this._loopEntry.xPos, this._loopCanvases[this._loopEntry.canvasIndex].height - 60);\n        }\n      }\n    }\n\n    /** @method\r\n     * @name _getPlayerSourceFile\r\n     * @private\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Fetch audio file using xmlHTTP request.</blockquote> **/\n  }, {\n    key: \"_getPlayerSourceFile\",\n    value: function _getPlayerSourceFile() {\n      var _this4 = this;\n      var request = new XMLHttpRequest();\n      request.open('GET', this._player.src, true);\n      request.responseType = 'arraybuffer';\n      request.onload = function () {\n        _this4._processAudioFile(request.response);\n      };\n      request.send();\n    }\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n    /*  ----------------------------------------  TIMELINE PUBLIC METHODS  -------------------------------------------  */\n    /*                                                                                                                  */\n    /*  These methods allow the caller to update the beat info (on change track for example), or to add/remove a hot    */\n    /*  cue in the timeline, or to configure loop entry and exit                                                        */\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** @method\r\n     * @name updateBeatInfo\r\n     * @public\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Update the beat values. To be calle don change track</blockquote>\r\n     * @param {object} options - Track beat options\r\n     * @param {number} [options.beat.offset=null] - offset before first beat\r\n     * @param {number} [options.beat.bpm=null] - The track bpm\r\n     * @param {number} [options.beat.timeSignature=null] - The track time signature to emphasis main beats **/\n  }, {\n    key: \"updateBeatInfo\",\n    value: function updateBeatInfo(options) {\n      this._beat = {\n        offset: options.offset,\n        bpm: options.bpm,\n        timeSignature: options.timeSignature\n      };\n    }\n\n    /** @method\r\n     * @name setHotCuePoint\r\n     * @public\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Define a HotCue point. It will be attached to the nearest bar. It will only be\r\n     * attached if no hotcue is registered on the targeted bar.</blockquote>\r\n     * @return {object} The hotcue object with its information **/\n  }, {\n    key: \"setHotCuePoint\",\n    value: function setHotCuePoint(options) {\n      var matchingBeat = this.getClosestBeat();\n      // Search for existing hotcue at the target bar\n      var existingHotCue = null;\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        if (this._hotCues[i].beatCount === matchingBeat.beatCount) {\n          existingHotCue = this._hotCues[i];\n          break;\n        }\n      }\n      // Only append hotcue if it's not already registered, return existing hot cue otherwise\n      if (!existingHotCue) {\n        // Save hot cue and return to the sender\n        matchingBeat.number = this._hotCues.length + 1; // Attach hotcue number\n        matchingBeat.time = matchingBeat.xPos * this._canvasSpeed / this._canvas.width; // Save the bar timecode into the hotcue object\n        matchingBeat.label = this._hotCues.length + 1; // Default label\n        if (options.label) {\n          matchingBeat.label = options.label;\n        }\n        if (options.color) {\n          matchingBeat.color = options.color;\n        }\n        // Otherwise save hot cue in stack\n        this._hotCues.push(matchingBeat);\n        // Draw hotcues if any\n        this._clearCanvas();\n        this._drawHotCue(matchingBeat);\n        this._drawTimeline(this._player.currentTime);\n        return matchingBeat;\n      } else {\n        return existingHotCue;\n      }\n    }\n  }, {\n    key: \"updateHotCuePoint\",\n    value: function updateHotCuePoint(hotCue, options) {\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        if (this._hotCues[i].beatCount === hotCue.beatCount) {\n          if (options.label) {\n            this._hotCues[i].label = options.label;\n          }\n          if (options.color) {\n            this._hotCues[i].color = options.color;\n          }\n        }\n      }\n      this._clearCanvas(false, true);\n      this._drawHotCues();\n      this._drawTimeline(this._player.currentTime);\n    }\n  }, {\n    key: \"removeHotCuePoint\",\n    value: function removeHotCuePoint(hotcue) {\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        if (this._hotCues[i].beatCount === hotcue.beatCount) {\n          this._hotCues.splice(i, 1);\n          this._clearCanvas(false, true);\n          this._drawHotCues();\n          this._drawTimeline(this._player.currentTime);\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"setLoopEntryPoint\",\n    value: function setLoopEntryPoint() {\n      this._loopEntry = this.getClosestBeat();\n      this._clearCanvas(false, false, true);\n      this._drawLoop();\n      this._drawTimeline(this._player.currentTime);\n    }\n  }, {\n    key: \"setLoopEndPoint\",\n    value: function setLoopEndPoint(beatDuration) {\n      if (this._loopEntry) {\n        // Determine end by closest beat\n        if (!beatDuration) {\n          var matchingBeat = this.getClosestBeat();\n          // Only save end if not equal to entry and is located after in time\n          if (matchingBeat !== this._loopEntry && this._loopEntry.time < matchingBeat.time) {\n            this._loopEnd = matchingBeat;\n          }\n        } else {\n          // Determine end by a beat count after loop entry\n          if (this._loopEntry.beatCount + beatDuration < this._beatsArray.length) {\n            this._loopEnd = this._beatsArray[this._loopEntry.beatCount + beatDuration];\n          } else {\n            this._loopEnd = this._beatsArray[this._beatsArray.length - 1];\n          }\n        }\n        this._clearCanvas(false, false, true);\n        this._drawLoop();\n        this._drawTimeline(this._player.currentTime);\n        //this._startLoopSequence(!beatDuration);\n      }\n    }\n  }, {\n    key: \"exitLoop\",\n    value: function exitLoop() {\n      //this._loopBuffer.stop();\n      //this._player.play();\n      this._loopEntry = null;\n      this._loopEnd = null;\n      this._loopBuffer = null;\n      this._isLooping = false;\n      this._loopStartedAt = 0;\n      this._playerPausedAt = 0;\n      this._clearCanvas(false, false, true);\n      this._drawTimeline(this._player.currentTime);\n    }\n\n    /** @method\r\n     * @name getClosestBeat\r\n     * @public\r\n     * @memberof Timeline\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote></blockquote> **/\n  }, {\n    key: \"getClosestBeat\",\n    value: function getClosestBeat() {\n      var timeOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      // The center coordinate when this method is called\n      var center = Math.floor(this._player.currentTime * this._canvas.width / this._canvasSpeed);\n      var matchingBeat = {};\n      // Find nearest beat to process\n      for (var i = 0; i < this._beatsArray.length; ++i) {\n        // We now have the upper beat, compare with previous one to find nearest\n        if (this._beatsArray[i].xPos > center) {\n          // Take previous bar if click was closer to it\n          if (i - 1 > 0 && this._beatsArray[i].xPos - center > center - this._beatsArray[i - 1].xPos) {\n            matchingBeat = this._beatsArray[i - 1];\n            break;\n          } else {\n            // Take curent bar otherwise\n            matchingBeat = this._beatsArray[i];\n            break;\n          }\n        }\n      }\n      // Only return time if requested\n      if (timeOnly) {\n        return matchingBeat.time;\n      }\n      return matchingBeat;\n    }\n  }]);\n}(_utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Timeline);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/components/Timeline.js?");

/***/ }),

/***/ "./src/js/components/Waveform.js":
/*!***************************************!*\
  !*** ./src/js/components/Waveform.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/VisuComponentMono.js */ \"./src/js/utils/VisuComponentMono.js\");\n/* harmony import */ var _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/CanvasUtils.js */ \"./src/js/utils/CanvasUtils.js\");\n/* harmony import */ var _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ColorUtils.js */ \"./src/js/utils/ColorUtils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _superPropGet(t, e, r, o) { var p = _get(_getPrototypeOf(1 & o ? t.prototype : t), e, r); return 2 & o ? function (t) { return p.apply(r, t); } : p; }\nfunction _get() { return _get = \"undefined\" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\n\n\nvar Waveform = /*#__PURE__*/function (_VisuComponentMono) {\n  /** @summary Waveform displays the track audio waveform.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments VisuComponentMono\r\n   * @description <blockquote>This component will perform an offline analysis to display the whole track audio shape,\r\n   * and provide different colors to track the audio progress. It is interactive and will update the player's\r\n   * current time value to match the clicked one. This class extends VisuComponentMono only because it performs an offline\r\n   * analysis on audio and the stereo information are already held in audio buffer.</blockquote>\r\n   * @param {object} options - The waveform options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {string} [options.animation] - The track progress animation to be <code>gradient</code> or <code>fade</code>\r\n   * @param {object} [options.wave] - Wave potions\r\n   * @param {string} [options.wave.align='center'] - Wave alignment in <code>top</code>/<code>center</code>/<code>bottom</code>\r\n   * @param {number} [options.wave.barWidth=1] - The bar width in px\r\n   * @param {number} [options.wave.barMarginScale=0.125] - The margin scale of bar width in Float[0,1]\r\n   * @param {boolean} [options.wave.merged=true] - Symmetry if wave is align center\r\n   * @param {boolean} [options.wave.noSignalLine=true] - Display a line when no signal\r\n   * @param {object} [options.colors] - Waveform color potions\r\n   * @param {string} [options.colors.background='#1D1E25'] - Canvas background color in Hex/RGB/HSL\r\n   * @param {string} [options.colors.track='#E7E9E7'] - The waveform background color in Hex/RGB/HSL\r\n   * @param {string} [options.colors.progress='#56D45B'] - The waveform progress color in Hex/RGB/HSL\r\n   * @param {object[]} [options.hotCues=[]] - Hotcues sorted array to load waveform with. Each array item must contain a time key with its value **/\n  function Waveform(options) {\n    var _this;\n    _classCallCheck(this, Waveform);\n    _this = _callSuper(this, Waveform, [options]);\n    _this._colors = {\n      background: options.colors ? options.colors.background || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultBackgroundColor,\n      track: options.colors ? options.colors.track || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultTextColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultTextColor,\n      progress: options.colors ? options.colors.progress || _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultPrimaryColor : _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].defaultPrimaryColor\n    };\n    _this._canvas.style.backgroundColor = _this._colors.background;\n    if (_this._player.src !== '') {\n      _this._getPlayerSourceFile();\n    }\n    return _this;\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  --------------------------------------  VISUCOMPONENTMONO OVERRIDES  -----------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof Waveform\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The frequency circle options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {object} [options.wave] - Waveform potions\r\n   * @param {string} [options.wave.align='center'] - Waveform alignment in <code>top</code>/<code>center</code>/<code>bottom</code>\r\n   * @param {number} [options.wave.barWidth=1] - The bar width in px\r\n   * @param {number} [options.wave.barMarginScale=0] - The margin scale of bar width in Float[0,1]\r\n   * @param {boolean} [options.wave.merged=true] - Symmetry if wave is aligned to center\r\n   * @param {boolean} [options.wave.noSignalLine=true] - Display a line when no signal\r\n   * @param {object[]} [options.hotCues=[]] - Hotcues sorted array to load waveform with. Each array item must contain a time key with its value **/\n  _inherits(Waveform, _VisuComponentMono);\n  return _createClass(Waveform, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      _superPropGet(Waveform, \"_fillAttributes\", this, 3)([options]);\n      this._animation = options.animation;\n      this._wave = {\n        align: options.wave ? options.wave.align || 'center' : 'center',\n        barWidth: options.wave ? options.wave.barWidth || 1 : 1,\n        barMarginScale: options.wave ? options.wave.barMarginScale / 2 : 0.125,\n        // Divide by 2 because true range is [0, 0.5]\n        merged: options.wave ? options.wave.merged === true ? true : false : false,\n        noSignalLine: options.wave ? options.wave.noSignalLine === true ? true : false : false\n      };\n      this._hotCues = options.hotCues || [];\n      this._bars = null; // Computed on build or resize\n      this._offlineCtx = null;\n      this._offlineBuffer = null;\n      // Raw channel data for whole audio file\n      this._dataL = [];\n      this._dataR = [];\n      // Event binding\n      this._trackLoaded = this._trackLoaded.bind(this);\n      this._onProgress = this._onProgress.bind(this);\n      this._onClick = this._onClick.bind(this);\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @override\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create and configure canvas then append it to given DOM element.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      _superPropGet(Waveform, \"_buildUI\", this, 3)([]);\n      this._bars = this._canvas.width / this._wave.barWidth;\n    }\n\n    /** @method\r\n     * @name _addEvents\r\n     * @private\r\n     * @override\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Add component events (resize, play, pause, dbclick).</blockquote> **/\n  }, {\n    key: \"_addEvents\",\n    value: function _addEvents() {\n      if (this._noEvents === false) {\n        _superPropGet(Waveform, \"_addEvents\", this, 3)([]);\n        this._player.addEventListener('loadedmetadata', this._trackLoaded, false);\n        this._player.addEventListener('seeking', this._onProgress, false);\n        this._dom.container.addEventListener('click', this._onClick, false);\n      }\n    }\n\n    /** @method\r\n     * @name _removeEvents\r\n     * @private\r\n     * @override\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Remove component events (resize, play, pause, dbclick).</blockquote> **/\n  }, {\n    key: \"_removeEvents\",\n    value: function _removeEvents() {\n      _superPropGet(Waveform, \"_removeEvents\", this, 3)([]);\n      this._player.removeEventListener('loadedmetadata', this._trackLoaded, false);\n      this._player.removeEventListener('seeking', this._onProgress, false);\n      this._dom.container.removeEventListener('click', this._onClick, false);\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @override\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      _superPropGet(Waveform, \"_onResize\", this, 3)([]);\n      this._bars = this._canvas.width / this._wave.barWidth;\n      this._fillData();\n      this._clearCanvas();\n      this._drawFileWaveform(this._player.currentTime / this._player.duration);\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress() {\n      this._clearCanvas();\n      this._drawFileWaveform(this._player.currentTime / this._player.duration);\n    }\n\n    /** @method\r\n     * @name _dblClick\r\n     * @private\r\n     * @override\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On double click event callback.</blockquote> **/\n  }, {\n    key: \"_dblClick\",\n    value: function _dblClick() {\n      // Required to revoke fullscreen toggle from parent class, as it interferes with seek feature\n    }\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @override\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Real time method called by WebAudioAPI to process PCM data. Here we make a 8 bit frequency\r\n     * and time analysis.</blockquote> **/\n  }, {\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      if (this._isPlaying === true) {\n        this._clearCanvas();\n        this._drawFileWaveform(this._player.currentTime / this._player.duration);\n        requestAnimationFrame(this._processAudioBin);\n      }\n    }\n\n    /*  ----------  Waveform internal methods  ----------  */\n\n    /** @method\r\n     * @name _trackLoaded\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Player callback on track loaded.</blockquote> **/\n  }, {\n    key: \"_trackLoaded\",\n    value: function _trackLoaded() {\n      cancelAnimationFrame(this._processAudioBin);\n      this._clearCanvas(); // Clear previous canvas\n      // Do XHR to request file and parse it\n      this._getPlayerSourceFile();\n    }\n\n    /** @method\r\n     * @name _onClick\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Update waveform progress according to mouse seek event.</blockquote>\r\n     * @param {object} event - The mouse event **/\n  }, {\n    key: \"_onClick\",\n    value: function _onClick(event) {\n      var rect = event.target.getBoundingClientRect();\n      var x = event.clientX - rect.left;\n      var y = event.clientY - rect.top;\n      var hotCue = this._hotCueClicked(x, y);\n      // Clicked on a hotcue\n      if (hotCue) {\n        this._player.currentTime = hotCue.time;\n      } else {\n        // Seek player otherwise\n        var boundingBox = event.target.getBoundingClientRect();\n        var xOffset = event.clientX - boundingBox.left;\n        this._player.currentTime = xOffset / this._canvas.width * this._player.duration;\n      }\n      // Clear canvas and drawwaveform with curent curent time\n      this._clearCanvas();\n      this._drawFileWaveform(this._player.currentTime / this._player.duration);\n    }\n\n    /** @method\r\n     * @name _processAudioFile\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Perform an offline analysis on whole track.</blockquote>\r\n     * @param {object} response - HTTP response for audio track to extract buffer from **/\n  }, {\n    key: \"_processAudioFile\",\n    value: function _processAudioFile(response) {\n      var _this2 = this;\n      // Set offline context according to track duration to get its full samples\n      this._offlineCtx = new OfflineAudioContext(2, this._audioCtx.sampleRate * this._player.duration, this._audioCtx.sampleRate);\n      this._offlineSource = this._offlineCtx.createBufferSource();\n      this._audioCtx.decodeAudioData(response, function (buffer) {\n        _this2._offlineSource.buffer = buffer;\n        _this2._offlineSource.connect(_this2._offlineCtx.destination);\n        _this2._offlineSource.start();\n        _this2._offlineCtx.startRendering().then(function (renderedBuffer) {\n          _this2._offlineBuffer = renderedBuffer;\n          _this2._fillData();\n          _this2._drawFileWaveform(_this2._player.currentTime / _this2._player.duration);\n        })[\"catch\"](function (err) {\n          console.log('Rendering failed: ' + err);\n        });\n      });\n    }\n\n    /** @method\r\n     * @name _fillData\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Generate merged or stereo data from audio buffer.</blockquote> **/\n  }, {\n    key: \"_fillData\",\n    value: function _fillData() {\n      if (this._offlineBuffer) {\n        if (this._wave.merged === true) {\n          // Mono output will only use L array to store L/R averages\n          this._dataL = this._genScaledMonoData(this._offlineBuffer);\n        } else {\n          this._dataL = this._genScaledData(this._offlineBuffer.getChannelData(0));\n          this._dataR = this._genScaledData(this._offlineBuffer.getChannelData(1));\n        }\n      }\n    }\n\n    /** @method\r\n     * @name _genScaledData\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>L/R Sub sample channel data to compute average value, depending on bar count.</blockquote>\r\n     * @param {Float32Array} data - Channel data (L/R here)\r\n     * @return {number[]} Array of height per sub samples **/\n  }, {\n    key: \"_genScaledData\",\n    value: function _genScaledData(data) {\n      var subSampleSize = Math.floor(data.length / this._bars);\n      var output = [];\n      // We need to sub sample raw data according to the bar number. We average fq values\n      for (var i = 0; i <= data.length - subSampleSize; i += subSampleSize) {\n        var sum = 0;\n        for (var j = 0; j < subSampleSize; ++j) {\n          sum += Math.abs(data[i + j]);\n        }\n        output.push(sum / subSampleSize);\n      }\n      return this._scaleDataToHeight(output);\n    }\n\n    /** @method\r\n     * @name _genScaledMonoData\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Merged L/R Sub sample channel data to compute average value, depending on bar count.</blockquote>\r\n     * @param {object} buffer - Audio buffer\r\n     * @return {number[]} Array of height per sub samples **/\n  }, {\n    key: \"_genScaledMonoData\",\n    value: function _genScaledMonoData(buffer) {\n      var dataL = buffer.getChannelData(0);\n      var dataR = buffer.getChannelData(1);\n      var subSampleSize = Math.floor(dataL.length / this._bars);\n      var output = [];\n\n      // We need to sub sample raw data according to the bar number. We average fq values\n      for (var i = 0; i <= dataL.length - subSampleSize; i += subSampleSize) {\n        var sum = 0;\n        for (var j = 0; j < subSampleSize; ++j) {\n          sum += (Math.abs(dataL[i + j]) + Math.abs(dataR[i + j])) / 2;\n        }\n        output.push(sum / subSampleSize);\n      }\n      return this._scaleDataToHeight(output);\n    }\n\n    /** @method\r\n     * @name _scaleDataToHeight\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Scale channel data into an array of height to be used in canvas on draw.</blockquote>\r\n     * @param {number[]} sampledData - Channel data\r\n     * @return {number[]} Array of height per sub samples **/\n  }, {\n    key: \"_scaleDataToHeight\",\n    value: function _scaleDataToHeight(sampledData) {\n      // Convert a range to another, maintaining ratio\n      // oldRange = (oldMax - oldMin)\n      // newRange = (newMax - newMin)\n      // newValue = (((oldValue - oldMin) * newRange) / oldRange) + NewMin */\n      // We take max value of sampled data as 90% height in canvas as ref\n      var oldMax = Math.max.apply(Math, _toConsumableArray(sampledData));\n      var oldMin = Math.min.apply(Math, _toConsumableArray(sampledData));\n      var oldRange = oldMax - oldMin;\n      var newRange = this._canvas.height * .9;\n      var scaledData = [];\n      for (var i = 0; i < sampledData.length; ++i) {\n        scaledData.push((sampledData[i] - oldMin) * newRange / oldRange);\n      }\n      return scaledData;\n    }\n\n    /** @method\r\n     * @name _drawFileWaveform\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw waveform with a given progress.</blockquote>\r\n     * @param {number} progressPercentage - Track progress percentage **/\n  }, {\n    key: \"_drawFileWaveform\",\n    value: function _drawFileWaveform(progressPercentage) {\n      var x = this._canvas.width / this._bars;\n      var margin = x * this._wave.barMarginScale;\n      this._ctx.beginPath();\n      // Iterate bar data\n      for (var i = 0; i < this._dataL.length; ++i) {\n        // Determine Y pos for Up and Down rectangles to draw (in mono, we only use merged data in dataL array)\n        var yU = this._dataL[i] / 2;\n        var yD = this._wave.merged === true ? this._dataL[i] / 2 : this._dataR[i] / 2;\n        // Determine bar color according to progress.\n        this._ctx.fillStyle = this._colors.track; // White by default (un-read yet)\n        if (x * (i + 1) / this._canvas.width > progressPercentage && x * i / this._canvas.width < progressPercentage) {\n          // Create linear gradient on bar X dimension\n          var gradient = this._ctx.createLinearGradient(x * i + margin, 0,\n          // Bar X start\n          x * (i + 1) - margin, 0 // Bar X end\n          );\n          // Get bar range in px\n          var barRange = x * (i + 1) - x * i;\n          // We get progress X position according to canvas width\n          var progressX = progressPercentage * this._canvas.width;\n          // Convert this width into a percentage of barWidth progression\n          var barProgressPercentage = Math.abs(progressX - x * i) / barRange;\n          if (this._animation === 'gradient') {\n            if (barProgressPercentage + 0.01 < 1) {\n              gradient.addColorStop(0, this._colors.progress); // Green\n              gradient.addColorStop(barProgressPercentage, this._colors.progress); // Green\n              gradient.addColorStop(barProgressPercentage + 0.01, this._colors.track); // Not progressive gradient\n              gradient.addColorStop(1, this._colors.track);\n              this._ctx.fillStyle = gradient; // Gradient from green to white with correct progression in bar\n            } else {\n              this._ctx.fillStyle = this._colors.progress; // Green full for last position in bars\n            }\n          } else {\n            var amount = Math.round(barProgressPercentage * 255);\n            this._ctx.fillStyle = _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].lightenDarkenColor(this._colors.progress, 255 - amount); // Green full for last position in bars\n          }\n        } else if (i / this._dataL.length < progressPercentage) {\n          this._ctx.fillStyle = this._colors.progress; // Green for already played bars\n        }\n        // Draw up and down rectangles for current bar\n        if (this._wave.align === 'center') {\n          this._ctx.fillRect(x * i + margin, this._canvas.height / 2 - yU, x - margin * 2, yU);\n          this._ctx.fillRect(x * i + margin, this._canvas.height / 2, x - margin * 2, yD);\n          // Add tiny centered line\n          if (this._wave.noSignalLine) {\n            this._ctx.fillRect(x * i + margin, this._canvas.height / 2 - 0.5, x - margin * 2, 1);\n          }\n        } else if (this._wave.align === 'bottom') {\n          this._ctx.fillRect(x * i + margin, this._canvas.height - yU, x - margin * 2, yU);\n          this._ctx.fillRect(x * i + margin, this._canvas.height - yU - yD + 1, x - margin * 2, yD); // Offset one pixel origin to blend channel properly\n        } else if (this._wave.align === 'top') {\n          // Stack L/R on each other\n          this._ctx.fillRect(x * i + margin, 0, x - margin * 2, yU);\n          this._ctx.fillRect(x * i + margin, yU - 1, x - margin * 2, yD); // Offset one pixel origin to blend channel properly\n        }\n      }\n      this._ctx.closePath();\n      // Draw hot cues if any\n      this._drawHotCues();\n    }\n  }, {\n    key: \"_drawHotCues\",\n    value: function _drawHotCues() {\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        this._drawHotCue(this._hotCues[i]);\n      }\n    }\n  }, {\n    key: \"_drawHotCue\",\n    value: function _drawHotCue(hotCue) {\n      _utils_CanvasUtils_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawHotCue(this._canvas, {\n        x: hotCue.time * this._canvas.width / this._player.duration + 18 / 2,\n        // By default, hotCue is centered on xPos. We don't wnat that behoavior here\n        y: 2,\n        size: 18,\n        label: hotCue.label || hotCue.number,\n        color: hotCue.color\n      });\n    }\n  }, {\n    key: \"_hotCueClicked\",\n    value: function _hotCueClicked(x, y) {\n      if (y > 2 && y < 20) {\n        for (var i = 0; i < this._hotCues.length; ++i) {\n          var xPos = this._hotCues[i].time * this._canvas.width / this._player.duration;\n          if (x > xPos && x < xPos + 18) {\n            return this._hotCues[i];\n          }\n        }\n      }\n      return false;\n    }\n\n    /** @method\r\n     * @name _getPlayerSourceFile\r\n     * @private\r\n     * @memberof Waveform\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Fetch audio file using xmlHTTP request.</blockquote> **/\n  }, {\n    key: \"_getPlayerSourceFile\",\n    value: function _getPlayerSourceFile() {\n      var _this3 = this;\n      var request = new XMLHttpRequest();\n      request.open('GET', this._player.src, true);\n      request.responseType = 'arraybuffer';\n      request.onload = function () {\n        _this3._processAudioFile(request.response);\n      };\n      request.send();\n    }\n  }, {\n    key: \"setHotCuePoint\",\n    value: function setHotCuePoint(hotCue) {\n      // This is just to add a new cuepoint, extracted from a Timeline component.\n      var existingHotCue = null;\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        if (this._hotCues[i].beatCount === hotCue.beatCount) {\n          existingHotCue = this._hotCues[i];\n          break;\n        }\n      }\n      if (!existingHotCue) {\n        this._hotCues.push(hotCue);\n        this._drawHotCues();\n      }\n    }\n  }, {\n    key: \"updateHotCuePoint\",\n    value: function updateHotCuePoint(hotCue, options) {\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        if (this._hotCues[i].beatCount === hotCue.beatCount) {\n          if (options.label) {\n            this._hotCues[i].label = options.label;\n          }\n          if (options.color) {\n            this._hotCues[i].color = options.color;\n          }\n        }\n      }\n      this._clearCanvas();\n      this._drawFileWaveform(this._player.currentTime / this._player.duration);\n    }\n  }, {\n    key: \"removeHotCuePoint\",\n    value: function removeHotCuePoint(hotCue) {\n      for (var i = 0; i < this._hotCues.length; ++i) {\n        if (this._hotCues[i].beatCount === hotCue.beatCount) {\n          this._hotCues.splice(i, 1);\n          this._clearCanvas();\n          this._drawFileWaveform(this._player.currentTime / this._player.duration);\n          break;\n        }\n      }\n    }\n  }]);\n}(_utils_VisuComponentMono_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Waveform);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/components/Waveform.js?");

/***/ }),

/***/ "./src/js/utils/BaseComponent.js":
/*!***************************************!*\
  !*** ./src/js/utils/BaseComponent.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar BaseComponent = /*#__PURE__*/function () {\n  /** @summary BaseComponent is the bedrock of any visualisation here. It must be inherited from Mono or Stereo component abstractions.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Store all base method, mostly to handle events, other processing methods needs to be overridden.</blockquote> **/\n  function BaseComponent() {\n    _classCallCheck(this, BaseComponent);\n    /** @private\r\n     * @member {string} - The component type. See supported componenets in AudioVisualizer factory */\n    this._type = null;\n    /** @private\r\n     * @member {object} - The audio source (HTML audio player) */\n    this._player = null;\n    /** @private\r\n     * @member {object} - Target div to render module in */\n    this._renderTo = null;\n    /** @private\r\n     * @member {number} - FFT size used to analyse audio stream. Must be a power of 2 */\n    this._fftSize = null;\n    /** @private\r\n     * @member {object} - The audio context */\n    this._audioCtx = null;\n    /** @private\r\n     * @member {object} - The source node to chain from ; it will ignore the output of HTML audio player */\n    this._inputNode = null;\n    /** @private\r\n     * @member {boolean} - The playing state of the player */\n    this._isPlaying = false;\n    /** @private\r\n     * @member {object} - Contains all useful DOM objects */\n    this._dom = {\n      container: null\n    };\n    /** @private\r\n     * @member {object} - Save container dimension to restore when closing fullscreen */\n    this._parentDimension = {\n      position: null,\n      height: null,\n      width: null,\n      zIndex: null\n    };\n    /** @private\r\n     * @member {object} - Resize observable to watch for any resize change */\n    this._resizeObserver = null;\n    // Event binding\n    this._onResize = this._onResize.bind(this);\n    this._play = this._play.bind(this);\n    this._pause = this._pause.bind(this);\n    this._dblClick = this._dblClick.bind(this);\n    // Bind process audio bin for add and remove event on demand\n    this._processAudioBin = this._processAudioBin.bind(this);\n  }\n\n  /** @method\r\n   * @name destroy\r\n   * @public\r\n   * @memberof BaseComponent\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>The destroy method to clear events and remove all component properties.</blockquote> **/\n  return _createClass(BaseComponent, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this = this;\n      this._removeEvents();\n      Object.keys(this).forEach(function (key) {\n        delete _this[key];\n      });\n    }\n\n    /** @method\r\n     * @name _fillAttributes\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Build component properties from options. Must be implemented in sub class.</blockquote> **/\n  }, {\n    key: \"_fillAttributes\",\n    value: function _fillAttributes() {\n      // Must be implemented in sub class\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create, configure and append UI in DOM. Must be implemented in sub class.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      // Must be implemented in sub class\n    }\n\n    /** @method\r\n     * @name _setAudioNodes\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Build audio chain with source. Must be implemented in sub class.</blockquote> **/\n  }, {\n    key: \"_setAudioNodes\",\n    value: function _setAudioNodes() {\n      // Must be implemented in sub class\n    }\n\n    /** @method\r\n     * @name _processAudioBin\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Real time audio analysis using PCM data from WebAudioAPI. Must be implemented in sub class.</blockquote> **/\n  }, {\n    key: \"_processAudioBin\",\n    value: function _processAudioBin() {\n      // Must be implemented in sub class\n    }\n\n    /** @method\r\n     * @name _addEvents\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Add component events (resize, play, pause, dbclick).</blockquote> **/\n  }, {\n    key: \"_addEvents\",\n    value: function _addEvents() {\n      // Put observer on renderTo and callback onResize at each action\n      this._resizeObserver = new ResizeObserver(this._onResize);\n      this._resizeObserver.observe(this._renderTo);\n      // Playback events\n      this._player.addEventListener('play', this._play, false);\n      this._player.addEventListener('pause', this._pause, false);\n      // Double click handler (fullscreen for most components)\n      this._dom.container.addEventListener('dblclick', this._dblClick, false);\n    }\n\n    /** @method\r\n     * @name _removeEvents\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Remove component events (resize, play, pause, dbclick).</blockquote> **/\n  }, {\n    key: \"_removeEvents\",\n    value: function _removeEvents() {\n      // Clear observable\n      this._resizeObserver.disconnect();\n      // Clear playback events\n      this._player.removeEventListener('play', this._play, false);\n      this._player.removeEventListener('pause', this._pause, false);\n      // Remove double click listener\n      this._dom.container.removeEventListener('dblclick', this._dblClick, false);\n    }\n\n    /** @method\r\n     * @name _play\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On play event callback.</blockquote> **/\n  }, {\n    key: \"_play\",\n    value: function _play() {\n      this._audioCtx.resume();\n      this._isPlaying = true;\n      this._processAudioBin();\n    }\n\n    /** @method\r\n     * @name _pause\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On pause event callback.</blockquote> **/\n  }, {\n    key: \"_pause\",\n    value: function _pause() {\n      this._audioCtx.suspend();\n      this._isPlaying = false;\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback. Must be implemented in sub class.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      // Resize must be handled in each sub class\n    }\n\n    /** @method\r\n     * @name _dblClick\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On double click event callback (toggle fullscreen).</blockquote> **/\n  }, {\n    key: \"_dblClick\",\n    value: function _dblClick() {\n      var _this2 = this;\n      if (document.fullscreenElement) {\n        document.exitFullscreen().then(function () {\n          // Restore renderTo initial style\n          _this2._renderTo.style.position = _this2._parentDimension.position;\n          _this2._renderTo.style.height = _this2._parentDimension.height;\n          _this2._renderTo.style.width = _this2._parentDimension.width;\n          _this2._renderTo.style.zIndex = _this2._parentDimension.zIndex;\n          _this2._parentDimension = {\n            position: null,\n            height: null,\n            width: null,\n            zIndex: null\n          };\n        });\n      } else {\n        document.documentElement.requestFullscreen().then(function () {\n          // Update renderTo dimension (canvas will be automatically rescaled)\n          _this2._parentDimension = {\n            position: _this2._renderTo.style.position,\n            height: _this2._renderTo.style.height,\n            width: _this2._renderTo.style.width,\n            zIndex: _this2._renderTo.style.zIndex || ''\n          };\n          // Alter render to style to make it fullscreen\n          _this2._renderTo.style.position = 'fixed';\n          _this2._renderTo.style.height = '100vh';\n          _this2._renderTo.style.width = '100vw';\n          _this2._renderTo.style.zIndex = '999';\n        });\n      }\n    }\n\n    /** @method\r\n     * @name _clearCanvas\r\n     * @private\r\n     * @memberof BaseComponent\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Clear component canvas contexts from their content. Must be implemented in sub class.</blockquote> **/\n  }, {\n    key: \"_clearCanvas\",\n    value: function _clearCanvas() {\n      // Clear canvas must be handled in Mono/Stereo sub class depending on amount of canvas\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BaseComponent);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/utils/BaseComponent.js?");

/***/ }),

/***/ "./src/js/utils/CanvasUtils.js":
/*!*************************************!*\
  !*** ./src/js/utils/CanvasUtils.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ColorUtils.js */ \"./src/js/utils/ColorUtils.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar CanvasUtils = /*#__PURE__*/function () {\n  /** @summary CanvasUtils provides several method to manipulate basic geometries in canvas\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>This class doesn't need to be instantiated, as all its methods are static in order to\r\n   * make those utils methods available with constraints. Refer to each method for their associated documentation.</blockquote> */\n  function CanvasUtils() {\n    _classCallCheck(this, CanvasUtils);\n  }\n\n  /** @method\r\n   * @name drawRadialBar\r\n   * @public\r\n   * @memberof CanvasUtils\r\n   * @static\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Draw a radial bar with its height and color being computed from the frequency intensity.</blockquote>\r\n   * @param {object} canvas - The canvas to draw radial bar in\r\n   * @param {object} options - Radial bar options\r\n   * @param {object} options.frequencyValue - The frequency value in Int[0,255]\r\n   * @param {number} options.x0 - The x origin in canvas dimension\r\n   * @param {number} options.y0 - The y origin in canvas dimension\r\n   * @param {number} options.x1 - The x endpoint in canvas dimension\r\n   * @param {number} options.y1 - The y endpoint in canvas dimension\r\n   * @param {number} options.width - The bar line width in N\r\n   * @param {string} options.color - The bar base color (will be lighten/darken according to frequency value) in Hex/RGB/HSL **/\n  return _createClass(CanvasUtils, null, [{\n    key: \"drawRadialBar\",\n    value: function drawRadialBar(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      var amount = options.frequencyValue / 255;\n      // Draw on canvas context\n      ctx.beginPath();\n      ctx.moveTo(options.x0, options.y0);\n      ctx.lineTo(options.x1, options.y1);\n      ctx.strokeStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].lightenDarkenColor(options.color, amount * 100);\n      ctx.lineWidth = options.width;\n      ctx.stroke();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawCircle\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a circle in given canvas.</blockquote>\r\n     * @param {object} canvas - The canvas to draw circle in\r\n     * @param {object} options - Circle options\r\n     * @param {number} options.centerX - The circle x origin in canvas dimension\r\n     * @param {number} options.centerY - The circle y origin in canvas dimension\r\n     * @param {number} options.radius - The circle radius\r\n     * @param {number} options.radStart - The rotation start angle in rad\r\n     * @param {number} options.radEnd - The rotation end angle in rad\r\n     * @param {number} options.width - The circle line width in N\r\n     * @param {string} options.color - The circle color in Hex/RGB/HSL **/\n  }, {\n    key: \"drawCircle\",\n    value: function drawCircle(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      ctx.arc(options.centerX, options.centerY, options.radius, options.radStart, options.radEnd);\n      ctx.lineWidth = options.width;\n      ctx.strokeStyle = options.color;\n      ctx.stroke();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawCircleGlow\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a circle with glow effect made with radial gradients in inner and outer circle.</blockquote>\r\n     * @param {object} canvas - The canvas to draw circle glow in\r\n     * @param {object} options - Circle glow options\r\n     * @param {number} options.centerX - The circle x origin in canvas dimension\r\n     * @param {number} options.centerY - The circle y origin in canvas dimension\r\n     * @param {number} options.radius - The circle radius\r\n     * @param {number} options.radStart - The rotation start angle in rad\r\n     * @param {number} options.radEnd - The rotation end angle in rad\r\n     * @param {number} options.width - The circle line width in N\r\n     * @param {object[]} options.colors - the glow color, must be objects with color (in Hex/RGB/HSL) and index (in Float[0,1], 0.5 being the circle line) properties  **/\n  }, {\n    key: \"drawCircleGlow\",\n    value: function drawCircleGlow(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      ctx.arc(options.centerX, options.centerY, options.radius, options.radStart, options.radEnd);\n      ctx.fillStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].radialGlowGradient(canvas, options);\n      ctx.fill();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawDisc\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a disc in given canvas.</blockquote>\r\n     * @param {object} canvas - The canvas to draw disc in\r\n     * @param {object} options - Disc options\r\n     * @param {number} options.centerX - The circle x origin in canvas dimension\r\n     * @param {number} options.centerY - The circle y origin in canvas dimension\r\n     * @param {number} options.radius - The circle radius\r\n     * @param {number} options.radStart - The rotation start angle in rad\r\n     * @param {number} options.radEnd - The rotation end angle in rad\r\n     * @param {string} options.color - The circle color in Hex/RGB/HSL **/\n  }, {\n    key: \"drawDisc\",\n    value: function drawDisc(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      ctx.arc(options.centerX, options.centerY, options.radius, options.radStart, options.radEnd);\n      ctx.fillStyle = options.color;\n      ctx.fill();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawVerticalBar\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a disc vertical bar in given canvas with given gradient.</blockquote>\r\n     * @param {object} canvas - The canvas to draw disc in\r\n     * @param {object} options - Vertical bar options\r\n     * @param {number} options.originX - The x origin in canvas dimension\r\n     * @param {number} options.height - The height of the frequency bin in canvas dimension\r\n     * @param {number} options.width - The width of the frequency bin in canvas dimension\r\n     * @param {object[]} options.colors - the gradient colors, must be objects with color and index (in Float[0,1]) properties **/\n  }, {\n    key: \"drawVerticalBar\",\n    value: function drawVerticalBar(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      ctx.fillRect(options.originX, canvas.height - options.height, options.width, options.height);\n      options.vertical = true; // Enforce vertical gradient\n      ctx.fillStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].linearGradient(canvas, options);\n      ctx.fillRect(options.originX, canvas.height - options.height, options.width, options.height);\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawOscilloscope\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw an oscilloscope of frequencies in given canvas.</blockquote>\r\n     * @param {object} canvas - The canvas to draw disc in\r\n     * @param {object} options - Oscilloscope options\r\n     * @param {number} options.samples - The x origin in canvas dimension\r\n     * @param {number} options.timeDomain - The height of the frequency bin in canvas dimension\r\n     * @param {string|array} options.color - the oscilloscope color in Hex/RGB/HSL or <code>rainbow</code> **/\n  }, {\n    key: \"drawOscilloscope\",\n    value: function drawOscilloscope(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      // Iterate over data to build each bar\n      var cursorX = 0;\n      var frequencyWidth = canvas.width / options.samples;\n      for (var i = 0; i < options.samples; ++i) {\n        // Compute frequency height percentage relative to canvas height to determine Y origin\n        var frequencyHeight = options.timeDomain[i] / 255; // Get value between 0 and 1\n        var cursorY = canvas.height * frequencyHeight;\n        if (i > 0) {\n          // General case\n          ctx.lineTo(cursorX, cursorY);\n        } else {\n          // 0 index case\n          ctx.moveTo(cursorX, cursorY);\n        }\n        // Update cursor position\n        cursorX += frequencyWidth;\n      }\n      if (options.colors === 'rainbow') {\n        ctx.strokeStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rainbowLinearGradient(canvas);\n      } else if (Array.isArray(options.colors)) {\n        ctx.strokeStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].linearGradient(canvas, options);\n      } else {\n        ctx.strokeStyle = options.colors;\n      }\n      ctx.stroke();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawPointsOscilloscope\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw an oscilloscope as points only in given canvas.</blockquote>\r\n     * @param {object} canvas - The canvas to draw disc in\r\n     * @param {object} options - Oscilloscope options\r\n     * @param {number} options.length - the oscilloscope length (half FFT)\r\n     * @param {number} options.times - The time domain bins\r\n     * @param {string} options.color - The point color in Hex/RGB/HSL **/\n  }, {\n    key: \"drawPointsOscilloscope\",\n    value: function drawPointsOscilloscope(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      for (var i = 0; i < options.length; ++i) {\n        var height = canvas.height * (options.times[i] / 255);\n        var offset = canvas.height - height - 1;\n        var barWidth = canvas.width / options.length;\n        ctx.fillStyle = options.color;\n        ctx.fillRect(i * barWidth, offset, 2, 2);\n      }\n      ctx.stroke();\n      ctx.fill();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawRadialOscilloscope\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a radial oscilloscope as points only in given canvas.</blockquote>\r\n     * @param {object} canvas - The canvas to draw disc in\r\n     * @param {object} options - Oscilloscope options\r\n     * @param {number} options.centerX - the x center position\r\n     * @param {number} options.centerY - the y center position\r\n     * @param {number} options.rotation - the rotation offset\r\n     * @param {number} options.length - the oscilloscope length (half FFT)\r\n     * @param {number[]} options.times - The time domain bins\r\n     * @param {number[]} options.points - The oscilloscope radial points objects\r\n     * @param {string} options.color - The point color in Hex/RGB/HSL **/\n  }, {\n    key: \"drawRadialOscilloscope\",\n    value: function drawRadialOscilloscope(canvas, options) {\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      ctx.save();\n      ctx.translate(options.centerX, options.centerY);\n      ctx.rotate(options.rotation);\n      ctx.translate(-options.centerX, -options.centerY);\n      ctx.moveTo(options.points[0].dx, options.points[0].dy);\n      ctx.strokeStyle = options.color;\n      for (var i = 0; i < options.length - 1; ++i) {\n        var _point = options.points[i];\n        _point.dx = _point.x + options.times[i] * Math.sin(Math.PI / 180 * _point.angle);\n        _point.dy = _point.y + options.times[i] * Math.cos(Math.PI / 180 * _point.angle);\n        var _xc = (_point.dx + options.points[i + 1].dx) / 2;\n        var _yc = (_point.dy + options.points[i + 1].dy) / 2;\n        ctx.quadraticCurveTo(_point.dx, _point.dy, _xc, _yc);\n      }\n      // Handle last point manually\n      var value = options.times[options.length - 1];\n      var point = options.points[options.length - 1];\n      point.dx = point.x + value * Math.sin(Math.PI / 180 * point.angle);\n      point.dy = point.y + value * Math.cos(Math.PI / 180 * point.angle);\n      var xc = (point.dx + options.points[0].dx) / 2;\n      var yc = (point.dy + options.points[0].dy) / 2;\n      ctx.quadraticCurveTo(point.dx, point.dy, xc, yc);\n      ctx.quadraticCurveTo(xc, yc, options.points[0].dx, options.points[0].dy);\n      // Fill context for current path\n      ctx.lineWidth = 1;\n      ctx.lineCap = 'round';\n      ctx.stroke();\n      ctx.restore();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawPeakMeter\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a peakmeter in given canvas.</blockquote>\r\n     * @param {object} canvas - The canvas to draw disc in\r\n     * @param {object} options - Peak meter options\r\n     * @param {string} options.orientation - The peak meter orientation, either <code>horizontal</code> or <code>vertical</code>\r\n     * @param {number} options.amplitude - The sample amplitude value\r\n     * @param {number} options.peak - The peak value\r\n     * @param {object[]} options.colors - The peak meter gradient colors, must be objects with color and index (in Float[0,1]) properties **/\n  }, {\n    key: \"drawPeakMeter\",\n    value: function drawPeakMeter(canvas, options) {\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null || options === undefined || options === null) {\n        return new Error('CanvasUtils.drawPeakMeter : Missing arguments canvas or options');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || _typeof(options) !== 'object') {\n        return new Error('CanvasUtils.drawPeakMeter : Invalid type for canvas or options');\n      }\n      // Test if options contains other mandatory args\n      if (options.orientation === undefined || options.orientation === null || options.amplitude === undefined || options.amplitude === null || options.peak === undefined || options.peak === null || options.colors === undefined || options.colors === null) {\n        return new Error('CanvasUtils.drawPeakMeter : Missing arguments options.orientation or options.amplitude or options.peak or options.top');\n      }\n      // Perform method purpose\n      var ctx = canvas.getContext('2d');\n      options.vertical = options.orientation === 'vertical';\n      ctx.fillStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].linearGradient(canvas, options);\n      ctx.fill();\n      if (options.orientation === 'horizontal') {\n        var ledWidth = canvas.width - options.amplitude;\n        ctx.fillRect(0, 0, ledWidth, canvas.height);\n      } else if (options.orientation === 'vertical') {\n        var ledHeight = canvas.height - options.amplitude;\n        ctx.fillRect(0, canvas.height - ledHeight, canvas.width, ledHeight);\n      }\n      // Draw maximus bar\n      ctx.fillStyle = '#FF6B67';\n      if (options.orientation === 'horizontal') {\n        var _ledWidth = canvas.width - options.peak;\n        ctx.fillRect(_ledWidth, 0, 1, canvas.height);\n      } else if (options.orientation === 'vertical') {\n        var _ledHeight = canvas.height - options.peak;\n        ctx.fillRect(0, canvas.height - _ledHeight, canvas.width, 1);\n      }\n    }\n\n    /** @method\r\n     * @name drawTriangle\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a triangle in given canvas.</blockquote>\r\n     * @param {object} canvas - The canvas to draw disc in\r\n     * @param {object} options - Peak meter options\r\n     * @param {number} options.x - The triangle x origin\r\n     * @param {number} options.y - The triangle y origin\r\n     * @param {number} options.radius - The triangle base\r\n     * @param {number} options.top - The triangle top position **/\n  }, {\n    key: \"drawTriangle\",\n    value: function drawTriangle(canvas, options) {\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null || options === undefined || options === null) {\n        return new Error('CanvasUtils.drawTriangle : Missing arguments canvas or options');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || _typeof(options) !== 'object') {\n        return new Error('CanvasUtils.drawTriangle : Invalid type for canvas or options');\n      }\n      // Test if options contains other mandatory args\n      if (options.x === undefined || options.x === null || options.y === undefined || options.y === null || options.radius === undefined || options.radius === null || options.top === undefined || options.top === null) {\n        return new Error('CanvasUtils.drawTriangle : Missing arguments options.x or options.y or options.radius or options.top');\n      }\n      // Test mandatory arguments proper types\n      if (typeof options.x !== 'number' || typeof options.y !== 'number' || typeof options.radius !== 'number' || typeof options.top !== 'number') {\n        return new Error('CanvasUtils.drawTriangle : Invalid type for options.x or options.y or options.radius or options.top');\n      }\n      // Perform method purpose\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      ctx.moveTo(options.x - options.radius, options.y);\n      ctx.lineTo(options.x + options.radius, options.y);\n      ctx.lineTo(options.x, options.top);\n      ctx.fill();\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawHotCue\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw a hotcue in given canvas. HotCue is a square with a label in it.</blockquote>\r\n     * @param {object} canvas - The canvas to draw hotcue in\r\n     * @param {object} options - Hot cue options\r\n     * @param {number} options.x - The hotcue x origin\r\n     * @param {number} options.y - The hotcue y origin\r\n     * @param {number} options.size - The hotcue dimension (height/width)\r\n     * @param {string} [options.color] - The hotcue color in Hex or css color\r\n     * @param {number} options.label - The hotcue label **/\n  }, {\n    key: \"drawHotCue\",\n    value: function drawHotCue(canvas, options) {\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null || options === undefined || options === null) {\n        return new Error('CanvasUtils.drawHotCue : Missing arguments canvas or options');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || _typeof(options) !== 'object') {\n        return new Error('CanvasUtils.drawHotCue : Invalid type for canvas or options');\n      }\n      // Test if options contains other mandatory args\n      if (options.x === undefined || options.x === null || options.y === undefined || options.y === null || options.size === undefined || options.size === null || options.label === undefined || options.label === null) {\n        return new Error('CanvasUtils.drawHotCue : Missing arguments options.x or options.y or options.size or options.label');\n      }\n      // Test mandatory arguments proper types\n      if (typeof options.x !== 'number' || typeof options.y !== 'number' || typeof options.size !== 'number' || typeof options.label !== 'string') {\n        return new Error('CanvasUtils.drawHotCue : Invalid type for options.x or options.y or options.size or options.label');\n      }\n      // Perform method purpose\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      // HotCue border\n      ctx.fillStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultBackgroundColor;\n      ctx.fillRect(options.x - options.size / 2 - 1, options.y - 1, options.size + 2, options.size + 2);\n      // Background rectangle\n      ctx.fillStyle = options.color || _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPrimaryColor;\n      ctx.fillRect(options.x - options.size / 2, options.y, options.size, options.size);\n      // Label text drawing\n      ctx.fillStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultBackgroundColor;\n      ctx.font = 'bold 8pt sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(options.label || '', options.x, options.y + 3 * options.size / 4);\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name drawBeatCount\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Draw in canvas the beat count and the bar count of current playback.</blockquote>\r\n     * @param {object} canvas - The canvas to draw hotcue in\r\n     * @param {object} options - Peak meter options\r\n     * @param {number} options.x - The hotcue x origin\r\n     * @param {number} options.y - The hotcue y origin\r\n     * @param {string} options.label - The bar count label **/\n  }, {\n    key: \"drawBeatCount\",\n    value: function drawBeatCount(canvas, options) {\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null || options === undefined || options === null) {\n        return new Error('CanvasUtils.drawBeatCount : Missing arguments canvas or options');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || _typeof(options) !== 'object') {\n        return new Error('CanvasUtils.drawBeatCount : Invalid type for canvas or options');\n      }\n      // Test if options contains other mandatory args\n      if (options.x === undefined || options.x === null || options.y === undefined || options.y === null || options.label === undefined || options.label === null) {\n        return new Error('CanvasUtils.drawBeatCount : Missing arguments options.x or options.y or options.label');\n      }\n      // Test mandatory arguments proper types\n      if (typeof options.x !== 'number' || typeof options.y !== 'number' || typeof options.label !== 'string') {\n        return new Error('CanvasUtils.drawBeatCount : Invalid type for options.x or options.y or options.label');\n      }\n      // Perform method purpose\n      var ctx = canvas.getContext('2d');\n      ctx.beginPath();\n      // Label text drawing\n      ctx.fillStyle = _ColorUtils_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].defaultPrimaryColor;\n      ctx.font = 'bold 10pt sans-serif';\n      ctx.textAlign = 'left';\n      ctx.fillText(\"\".concat(options.label, \" Bars\"), options.x, options.y);\n      ctx.closePath();\n    }\n\n    /** @method\r\n     * @name precisionRound\r\n     * @public\r\n     * @memberof CanvasUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Round a floating number with a given precision after coma.</blockquote>\r\n     * @param {number} value - The floating value to round\r\n     * @param {number} precision - the amount of number we want to have after floating point\r\n     * @return {number} - The rounded value **/\n  }, {\n    key: \"precisionRound\",\n    value: function precisionRound(value, precision) {\n      // Test that caller sent mandatory arguments\n      if (value === undefined || value === null || precision === undefined || precision === null) {\n        return new Error('CanvasUtils.precisionRound : Missing arguments value or precision');\n      }\n      // Test those arguments proper types\n      if (typeof value !== 'number' || typeof precision !== 'number') {\n        return new Error('CanvasUtils.precisionRound : Invalid type for value or precision');\n      }\n      // Perform method purpose\n      var multiplier = Math.pow(10, precision || 0);\n      return Math.round(value * multiplier) / multiplier;\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanvasUtils);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/utils/CanvasUtils.js?");

/***/ }),

/***/ "./src/js/utils/ColorUtils.js":
/*!************************************!*\
  !*** ./src/js/utils/ColorUtils.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar ColorUtils = /*#__PURE__*/function () {\n  /** @summary ColorUtils provides several method to abstract color manipulation for canvas\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>This class doesn't need to be instantiated, as all its methods are static in order to\r\n   * make those utils methods available without constraints. Refer to each method for their associated documentation.</blockquote> */\n  function ColorUtils() {\n    _classCallCheck(this, ColorUtils);\n  }\n\n  /*  --------------------------------------------------------------------------------------------------------------- */\n  /*  --------------------------------------------  GRADIENT METHOD  -----------------------------------------------  */\n  /*  --------------------------------------------------------------------------------------------------------------- */\n\n  /** @method\r\n   * @name drawRadialGradient\r\n   * @public\r\n   * @memberof ColorUtils\r\n   * @static\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Fill context with radial gradient according to options object.</blockquote>\r\n   * @param {object} canvas - The canvas to draw radial gradient in\r\n   * @param {object} options - Radial gradient options\r\n   * @param {number} options.x0 - The x origin in canvas dimension\r\n   * @param {number} options.y0 - The y origin in canvas dimension\r\n   * @param {number} options.r0 - The radius of the start circle in Float[0,2PI]\r\n   * @param {number} options.x1 - The x endpoint in canvas dimension\r\n   * @param {number} options.y1 - The y endpoint in canvas dimension\r\n   * @param {number} options.r1 - The radius of the end circle in Float[0,2PI]\r\n   * @param {object[]} options.colors - The color gradient, must be objects with color (in Hex/RGB/HSL) and index (in Float[0,1]) properties **/\n  return _createClass(ColorUtils, null, [{\n    key: \"drawRadialGradient\",\n    value: function drawRadialGradient(canvas, options) {\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null || options === undefined || options === null) {\n        return new Error('ColorUtils.drawRadialGradient : Missing arguments canvas or options');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || _typeof(options) !== 'object') {\n        return new Error('ColorUtils.drawRadialGradient : Invalid type for canvas or options');\n      }\n      // Test if options.colors is properly formed\n      if (!options.colors || !Array.isArray(options.colors)) {\n        return new Error('ColorUtils.drawRadialGradient : Options object is not properly formed');\n      }\n      // Test if sent colors if properly formed of color/index objects\n      for (var i = 0; i < options.colors.length; ++i) {\n        if (options.colors[i].index === undefined || options.colors[i].index === null || typeof options.colors[i].index !== 'number' || options.colors[i].color === undefined || options.colors[i].color === null || typeof options.colors[i].color !== 'string') {\n          return new Error('ColorUtils.drawRadialGradient : Invalid type for a color sent in options object');\n        } else {\n          // Test tha index is in [0,1]\n          if (options.colors[i].index < 0 || options.colors[i].index > 1) {\n            return new Error('ColorUtils.drawRadialGradient : An index sent in options object is not a valid float in [0, 1]');\n          }\n        }\n      }\n      // Test if options contains other mandatory args (origin)\n      if (options.x0 === undefined || options.x0 === null || options.y0 === undefined || options.y0 === null || options.r0 === undefined || options.r0 === null) {\n        return new Error('ColorUtils.drawRadialGradient : Missing arguments options.x0 or options.y0 or options.r0');\n      }\n      // Test mandatory arguments proper types (origin)\n      if (typeof options.x0 !== 'number' || typeof options.y0 !== 'number' || typeof options.r0 !== 'number') {\n        return new Error('ColorUtils.drawRadialGradient : Invalid type for options.x0 or options.y0 or options.r0');\n      }\n      // Test if options contains other mandatory args (destination)\n      if (options.x1 === undefined || options.x1 === null || options.y1 === undefined || options.y1 === null || options.r1 === undefined || options.r1 === null) {\n        return new Error('ColorUtils.drawRadialGradient : Missing arguments options.x1 or options.y1 or options.r1');\n      }\n      // Test mandatory arguments proper types (destination)\n      if (typeof options.x1 !== 'number' || typeof options.y1 !== 'number' || typeof options.r1 !== 'number') {\n        return new Error('ColorUtils.drawRadialGradient : Invalid type for options.x1 or options.y1 or options.r1');\n      }\n      // Perform method purpose\n      var ctx = canvas.getContext('2d');\n      var gradient = ctx.createRadialGradient(options.x0, options.y0, options.r0, options.x1, options.y1, options.r1);\n      for (var _i = 0; _i < options.colors.length; ++_i) {\n        gradient.addColorStop(options.colors[_i].index, options.colors[_i].color);\n      }\n      ctx.fillStyle = gradient;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    /** @method\r\n     * @name radialGlowGradient\r\n     * @public\r\n     * @memberof ColorUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Returns a radial glowing gradient according to options object.</blockquote>\r\n     * @param {object} canvas - The canvas to draw radial glowing gradient in\r\n     * @param {object} options - Radial glowing gradient options\r\n     * @param {number} options.centerX - The center x origin in canvas dimension\r\n     * @param {number} options.centerY - The center y origin in canvas dimension\r\n     * @param {number} options.radius - The circle radius in canvas dimension\r\n     * @param {object[]} options.colors - The color gradient, must be objects with color (in Hex/RGB/HSL) and index (in Float[0,1]) properties\r\n     * @return {object} The radial glowing gradient to apply **/\n  }, {\n    key: \"radialGlowGradient\",\n    value: function radialGlowGradient(canvas, options) {\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null || options === undefined || options === null) {\n        return new Error('ColorUtils.radialGlowGradient : Missing arguments canvas or options');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || _typeof(options) !== 'object') {\n        return new Error('ColorUtils.radialGlowGradient : Invalid type for canvas or options');\n      }\n      // Test if options.colors is properly formed\n      if (!options.colors || !Array.isArray(options.colors)) {\n        return new Error('ColorUtils.radialGlowGradient : Options object is not properly formed');\n      }\n      // Test if sent colors if properly formed of color/index objects\n      for (var i = 0; i < options.colors.length; ++i) {\n        if (options.colors[i].index === undefined || options.colors[i].index === null || typeof options.colors[i].index !== 'number' || options.colors[i].color === undefined || options.colors[i].color === null || typeof options.colors[i].color !== 'string') {\n          return new Error('ColorUtils.radialGlowGradient : Invalid type for a color sent in options object');\n        } else {\n          // Test tha index is in [0,1]\n          if (options.colors[i].index < 0 || options.colors[i].index > 1) {\n            return new Error('ColorUtils.radialGlowGradient : An index sent in options object is not a valid float in [0, 1]');\n          }\n        }\n      }\n      // Test if options contains other mandatory args\n      if (options.centerX === undefined || options.centerX === null || options.centerY === undefined || options.centerY === null || options.radius === undefined || options.radius === null) {\n        return new Error('ColorUtils.radialGlowGradient : Missing arguments options.centerX or options.centerY or options.radius');\n      }\n      // Test mandatory arguments proper types\n      if (typeof options.centerX !== 'number' || typeof options.centerY !== 'number' || typeof options.radius !== 'number') {\n        return new Error('ColorUtils.radialGlowGradient : Invalid type for options.centerX or options.centerY or options.radius');\n      }\n      // Perform method purpose\n      var ctx = canvas.getContext('2d');\n      var gradient = ctx.createRadialGradient(options.centerX, options.centerY, 0, options.centerX, options.centerY, options.radius);\n      for (var _i2 = 0; _i2 < options.colors.length; ++_i2) {\n        gradient.addColorStop(options.colors[_i2].index, options.colors[_i2].color);\n      }\n      return gradient;\n    }\n\n    /** @method\r\n     * @name linearGradient\r\n     * @public\r\n     * @memberof ColorUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2021\r\n     * @description <blockquote>Returns a linear gradient according to options object.</blockquote>\r\n     * @param {object} canvas - The canvas to draw radial glowing gradient in\r\n     * @param {object} options - Linear gradient options\r\n     * @param {boolean} [options.vertical] - Draw the gradient vertically\r\n     * @param {object[]} options.colors - The color gradient, must be objects with color (in Hex or css colors) and index (in Float[0,1]) properties\r\n     * @return {object} The linear gradient to apply **/\n  }, {\n    key: \"linearGradient\",\n    value: function linearGradient(canvas, options) {\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null || options === undefined || options === null) {\n        return new Error('ColorUtils.linearGradient : Missing arguments canvas or options');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || _typeof(options) !== 'object') {\n        return new Error('ColorUtils.linearGradient : Invalid type for canvas or options');\n      }\n      // Test if options.colors is properly formed\n      if (!options.colors || !Array.isArray(options.colors)) {\n        return new Error('ColorUtils.linearGradient : Options object is not properly formed');\n      }\n      // Test if sent colors if properly formed of color/index objects\n      for (var i = 0; i < options.colors.length; ++i) {\n        if (options.colors[i].index === undefined || options.colors[i].index === null || typeof options.colors[i].index !== 'number' || options.colors[i].color === undefined || options.colors[i].color === null || typeof options.colors[i].color !== 'string') {\n          return new Error('ColorUtils.linearGradient : Invalid type for a color sent in options object');\n        } else {\n          // Test tha index is in [0,1]\n          if (options.colors[i].index < 0 || options.colors[i].index > 1) {\n            return new Error('ColorUtils.linearGradient : An index sent in options object is not a valid float in [0, 1]');\n          }\n        }\n      }\n      // Perform method purpose\n      var ctx = canvas.getContext('2d');\n      var gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);\n      if (options.vertical === true) {\n        gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);\n      }\n      for (var _i3 = 0; _i3 < options.colors.length; ++_i3) {\n        gradient.addColorStop(options.colors[_i3].index, options.colors[_i3].color);\n      }\n      return gradient;\n    }\n\n    /** @method\r\n     * @name rainbowLinearGradient\r\n     * @public\r\n     * @memberof ColorUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Returns a vertical or horizontal rainbow gradient.</blockquote>\r\n     * @param {object} canvas - The canvas to create gradient from\r\n     * @param {boolean} [vertical=false] - The gradient orientation, default to horizontal\r\n     * @return {object} The rainbow gradient to apply **/\n  }, {\n    key: \"rainbowLinearGradient\",\n    value: function rainbowLinearGradient(canvas) {\n      var vertical = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Test that caller sent mandatory arguments\n      if (canvas === undefined || canvas === null) {\n        return new Error('ColorUtils.rainbowLinearGradient : Missing arguments canvas');\n      }\n      // Test those arguments proper types\n      if (canvas.nodeName !== 'CANVAS' || typeof vertical !== 'boolean') {\n        return new Error('ColorUtils.rainbowLinearGradient : Invalid type for canvas or vertical');\n      }\n      // Perform method purpose\n      return ColorUtils.linearGradient(canvas, {\n        vertical: vertical,\n        colors: [{\n          color: 'red',\n          index: 0\n        }, {\n          color: 'orange',\n          index: 1 / 7\n        }, {\n          color: 'yellow',\n          index: 2 / 7\n        }, {\n          color: 'green',\n          index: 3 / 7\n        }, {\n          color: 'blue',\n          index: 4 / 7\n        }, {\n          color: 'indigo',\n          index: 5 / 7\n        }, {\n          color: 'violet',\n          index: 6 / 7\n        }, {\n          color: 'red',\n          index: 1\n        }]\n      });\n    }\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n    /*  ---------------------------------------  COLOR MANIPULATION METHOD  ------------------------------------------  */\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** @method\r\n     * @name lightenDarkenColor\r\n     * @public\r\n     * @memberof ColorUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Lighten or darken a given color from an amount. Inspired from https://jsfiddle.net/gabrieleromanato/hrJ4X/</blockquote>\r\n     * @param {string} color - The color to alter in Hex\r\n     * @param {number} amount - The percentage amount to lighten or darken in Float[-100,100]\r\n     * @return {string} The altered color in Hex **/\n  }, {\n    key: \"lightenDarkenColor\",\n    value: function lightenDarkenColor(color, amount) {\n      // Test that caller sent mandatory arguments\n      if (color === undefined || color === null || amount === undefined || amount === null) {\n        return new Error('ColorUtils.lightenDarkenColor : Missing arguments color or amount');\n      }\n      // Test those arguments proper types\n      if (typeof color !== 'string' || typeof amount !== 'number') {\n        return new Error('ColorUtils.lightenDarkenColor : Invalid type for color or amount');\n      }\n      // Pound color value to remove # char and memorize it had one\n      var usePound = false;\n      if (color[0] === '#') {\n        color = color.slice(1);\n        usePound = true;\n      }\n      // Test that color is an hex code\n      if (!/^[a-fA-F0-9]+$/i.test(color)) {\n        return new Error('ColorUtils.lightenDarkenColor : Color is not a valid hexadecimal value');\n      }\n      // Check that alpha value is properly bounded to [0, 1]\n      if (amount < -100 || amount > 100) {\n        return new Error('ColorUtils.lightenDarkenColor : Amount is not a valid float in [-100, 100]');\n      }\n      if (amount === 0) {\n        return (usePound ? '#' : '') + color.toLowerCase();\n      }\n      if (amount > 0) {\n        amount += 16;\n      } else {\n        amount -= 16;\n      }\n      // Perform method purpose\n      var num = parseInt(color, 16);\n      // Red channel bounding\n      var r = (num >> 16) + amount;\n      if (r > 255) {\n        r = 255;\n      } else if (r < 0) {\n        r = 0;\n      }\n      // Blue channel bounding\n      var b = (num >> 8 & 0x00FF) + amount;\n      if (b > 255) {\n        b = 255;\n      } else if (b < 0) {\n        b = 0;\n      }\n      // Green channel bounding\n      var g = (num & 0x0000FF) + amount;\n      if (g > 255) {\n        g = 255;\n      } else if (g < 0) {\n        g = 0;\n      }\n      // Format returned hex value\n      return (usePound ? '#' : '') + (g | b << 8 | r << 16).toString(16);\n    }\n\n    /** @method\r\n     * @name alphaColor\r\n     * @public\r\n     * @memberof ColorUtils\r\n     * @static\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Add transparency on an existing color.</blockquote>\r\n     * @param {string} color - The color to make transparent in Hex\r\n     * @param {number} alpha - The amount of transparency applied on color in Float[0,1]\r\n     * @return {string} The transparent color in rgba **/\n  }, {\n    key: \"alphaColor\",\n    value: function alphaColor(color, alpha) {\n      // Test that caller sent mandatory arguments\n      if (color === undefined || color === null || alpha === undefined || alpha === null) {\n        return new Error('ColorUtils.alphaColor : Missing arguments color or alpha');\n      }\n      // Test those arguments proper types\n      if (typeof color !== 'string' || typeof alpha !== 'number') {\n        return new Error('ColorUtils.alphaColor : Invalid type for color or alpha');\n      }\n      // Remove # symbol if any on color value\n      if (color[0] === '#') {\n        color = color.slice(1);\n      }\n      // Test that color is an hex code\n      if (!/^[a-fA-F0-9]+$/i.test(color)) {\n        return new Error('ColorUtils.alphaColor : Color is not a valid hexadecimal value');\n      }\n      // Check that alpha value is properly bounded to [0, 1]\n      if (alpha < 0 || alpha > 1) {\n        return new Error('ColorUtils.alphaColor : Alpha is not a valid float in [0, 1]');\n      }\n      // Perform method purpose\n      var num = parseInt(color, 16);\n      return \"rgba(\".concat(num >> 16, \", \").concat(num >> 8 & 0x00FF, \", \").concat(num & 0x0000FF, \", \").concat(alpha, \")\");\n    }\n\n    /*  --------------------------------------------------------------------------------------------------------------- */\n    /*  ------------------------------------  COMPONENT DEFAULT COLORS METHOD  ---------------------------------------  */\n    /*  --------------------------------------------------------------------------------------------------------------- */\n\n    /** @public\r\n     * @static\r\n     * @member {string} - The default background color, #1D1E25 */\n  }, {\n    key: \"defaultBackgroundColor\",\n    get: function get() {\n      return '#1D1E25';\n    }\n\n    /** @public\r\n     * @static\r\n     * @member {string} - The default text color, #E7E9E7 */\n  }, {\n    key: \"defaultTextColor\",\n    get: function get() {\n      return '#E7E9E7';\n    }\n\n    /** @public\r\n     * @static\r\n     * @member {string} - The default primary color, #56D45B */\n  }, {\n    key: \"defaultPrimaryColor\",\n    get: function get() {\n      return '#56D45B';\n    }\n\n    /** @public\r\n     * @static\r\n     * @member {string} - The default anti primary color, #FF6B67 */\n  }, {\n    key: \"defaultAntiPrimaryColor\",\n    get: function get() {\n      return '#FF6B67';\n    }\n\n    /** @public\r\n     * @static\r\n     * @member {string} - The default dark primary color, #12B31D */\n  }, {\n    key: \"defaultDarkPrimaryColor\",\n    get: function get() {\n      return '#12B31D';\n    }\n\n    /** @public\r\n     * @static\r\n     * @member {string} - The default dark primary color, #FFAD67 */\n  }, {\n    key: \"defaultLoopColor\",\n    get: function get() {\n      return '#FFAD67';\n    }\n\n    /** @public\r\n     * @static\r\n     * @member {string} - The default dark primary color, #FFAD67 */\n  }, {\n    key: \"defaultLoopAlphaColor\",\n    get: function get() {\n      return this.alphaColor('FFAD67', 0.5);\n    }\n\n    /** @public\r\n     * @static\r\n     * @member {string[]} - The default color array to be used in gradient, <code>['#56D45B', '#AFF2B3', '#FFAD67', '#FF6B67', '#FFBAB8']</code> */\n  }, {\n    key: \"defaultAudioGradient\",\n    get: function get() {\n      return [{\n        color: '#56D45B',\n        index: 0\n      },\n      // Green\n      {\n        color: '#AFF2B3',\n        index: 0.7\n      },\n      // Light Green\n      {\n        color: '#FFAD67',\n        index: 0.833\n      },\n      // Orange\n      {\n        color: '#FF6B67',\n        index: 0.9\n      },\n      // Red\n      {\n        color: '#FFBAB8',\n        index: 1\n      } // Light Red\n      ];\n    }\n  }]);\n}();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ColorUtils);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/utils/ColorUtils.js?");

/***/ }),

/***/ "./src/js/utils/VisuComponentMono.js":
/*!*******************************************!*\
  !*** ./src/js/utils/VisuComponentMono.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _BaseComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseComponent.js */ \"./src/js/utils/BaseComponent.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar VisuComponentMono = /*#__PURE__*/function (_BaseComponent) {\n  /** @summary VisuComponentMono is an abstraction for mono visualisation component. It must be inherited.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments BaseComponent\r\n   * @description <blockquote>Mono components inherit this class to benefit its node routing and canvas\r\n   * configuration. It is meant to use a single canvas for mono or merged L/R audio channels. This class extends\r\n   * BaseComponent to benefits all shared properties between visualisations.</blockquote>\r\n   * @param {object} options - The visualizer root options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {boolean} [options.noEvents] - Force component to be inactive to events\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one **/\n  function VisuComponentMono(options) {\n    var _this;\n    _classCallCheck(this, VisuComponentMono);\n    _this = _callSuper(this, VisuComponentMono);\n    /** @private\r\n     * @member {object} - Audio nodes from web audio API to manipulate data with */\n    _this._nodes = {\n      source: null,\n      // HTML audio element\n      analyser: null // Analysis node\n    };\n    /** @private\r\n     * @member {boolean} - Force no events on components, must be handled in child class */\n    _this._noEvents = options.noEvents || true;\n    /** @private\r\n     * @member {object} - The canvas to rendered mono data to */\n    _this._canvas = null;\n    /** @private\r\n     * @member {object} - The canvas associated context */\n    _this._ctx = null;\n    // Construction sequence\n    _this._fillAttributes(options);\n    _this._buildUI();\n    _this._setAudioNodes();\n    _this._addEvents();\n    return _this;\n  }\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof VisuComponentMono\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The visualizer root options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one **/\n  _inherits(VisuComponentMono, _BaseComponent);\n  return _createClass(VisuComponentMono, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      this._type = options.type;\n      this._player = options.player;\n      this._renderTo = options.renderTo;\n      this._fftSize = options.fftSize;\n      this._audioCtx = options.audioContext;\n      this._inputNode = options.inputNode;\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @override\r\n     * @memberof VisuComponentMono\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create and configure canvas then append it to given DOM element.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      this._dom.container = document.createElement('DIV');\n      this._dom.container.classList.add(\"audio-\".concat(this._type));\n      this._canvas = document.createElement('CANVAS');\n      this._canvas.style.cssText = 'display:block;box-sizing:border-box;';\n      this._ctx = this._canvas.getContext('2d');\n      this._canvas.width = this._renderTo.offsetWidth;\n      this._canvas.height = this._renderTo.offsetHeight;\n      this._ctx.translate(0.5, 0.5);\n      this._dom.container.appendChild(this._canvas);\n      this._renderTo.appendChild(this._dom.container);\n    }\n\n    /** @method\r\n     * @name _setAudioNodes\r\n     * @private\r\n     * @override\r\n     * @memberof VisuComponentMono\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Build audio chain with source -> analyzer -> destination.</blockquote> **/\n  }, {\n    key: \"_setAudioNodes\",\n    value: function _setAudioNodes() {\n      var audioCtxSent = false;\n      if (!this._audioCtx) {\n        this._audioCtx = new AudioContext();\n        this._nodes.source = this._audioCtx.createMediaElementSource(this._player);\n      } else {\n        audioCtxSent = true;\n        this._nodes.source = this._inputNode;\n      }\n      this._nodes.analyser = this._audioCtx.createAnalyser();\n      this._nodes.analyser.fftSize = this._fftSize;\n      this._nodes.source.connect(this._nodes.analyser);\n      if (!audioCtxSent) {\n        this._nodes.analyser.connect(this._audioCtx.destination);\n      }\n    }\n\n    /** @method\r\n     * @name _onResize\r\n     * @private\r\n     * @override\r\n     * @memberof VisuComponentMono\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>On resize event callback.</blockquote> **/\n  }, {\n    key: \"_onResize\",\n    value: function _onResize() {\n      this._canvas.width = this._renderTo.offsetWidth;\n      this._canvas.height = this._renderTo.offsetHeight;\n    }\n\n    /** @method\r\n     * @name _clearCanvas\r\n     * @private\r\n     * @override\r\n     * @memberof VisuComponentMono\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Clear component canvas context from its content.</blockquote> **/\n  }, {\n    key: \"_clearCanvas\",\n    value: function _clearCanvas() {\n      this._canvas.getContext('2d').clearRect(0, 0, this._canvas.width, this._canvas.height);\n    }\n  }]);\n}(_BaseComponent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VisuComponentMono);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/utils/VisuComponentMono.js?");

/***/ }),

/***/ "./src/js/utils/VisuComponentStereo.js":
/*!*********************************************!*\
  !*** ./src/js/utils/VisuComponentStereo.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _BaseComponent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseComponent.js */ \"./src/js/utils/BaseComponent.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e; if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); return e; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _inherits(t, e) { if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, \"prototype\", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\n\nvar VisuComponentStereo = /*#__PURE__*/function (_BaseComponent) {\n  /** @summary VisuComponentStereo is an abstraction for stereo visualisation components. It must be inherited.\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @augments BaseComponent\r\n   * @description <blockquote>Stereo components inherit this class to benefit its node routing and canvas\r\n   * configuration. It is meant to use a L/R canvas for stereo or merged L/R one. This class extends BaseComponent to\r\n   * benefits all shared properties between visualisations.</blockquote>\r\n   * @param {object} options - The visualizer root options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {boolean} [options.noEvents] - Force component to be inactive to events\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {boolean} [options.merged=false] - Merge channels into mono output **/\n  function VisuComponentStereo(options) {\n    var _this;\n    _classCallCheck(this, VisuComponentStereo);\n    _this = _callSuper(this, VisuComponentStereo);\n    /** @private\r\n     * @member {boolean} - Merge L and R channel on output */\n    _this._merged = null;\n    /** @private\r\n     * @member {object} - Audio nodes from web audio API to manipulate data with */\n    _this._nodes = {\n      source: null,\n      // HTML audio element\n      splitter: null,\n      // Stereo channel splitting\n      merger: null,\n      // Merge channels into one\n      analyser: null,\n      // Merged stereo channels analysis\n      analyserL: null,\n      // Left channel analysis\n      analyserR: null // Right channel analysis\n    };\n    /** @private\r\n     * @member {boolean} - Force no events on components, must be handled in child class */\n    _this._noEvents = options.noEvents || true;\n    /** @private\r\n     * @member {object} - The canvas to rendered left channed data to */\n    _this._canvasL = null;\n    /** @private\r\n     * @member {object} - The canvas to rendered right channed data to */\n    _this._canvasR = null;\n    /** @private\r\n     * @member {object} - The left canvas associated context */\n    _this._ctxL = null;\n    /** @private\r\n     * @member {object} - The right canvas associated context */\n    _this._ctxR = null;\n    // Construction sequence\n    _this._fillAttributes(options);\n    _this._buildUI();\n    _this._setAudioNodes();\n    _this._addEvents();\n    return _this;\n  }\n\n  /** @method\r\n   * @name _fillAttributes\r\n   * @private\r\n   * @override\r\n   * @memberof VisuComponentStereo\r\n   * @author Arthur Beaulieu\r\n   * @since 2020\r\n   * @description <blockquote>Internal method to fill internal properties from options object sent to constructor.</blockquote>\r\n   * @param {object} options - The visualizer root options\r\n   * @param {string} options.type - The component type as string\r\n   * @param {object} options.player - The player to take as processing input (if inputNode is given, player source will be ignored)\r\n   * @param {object} options.renderTo - The DOM element to render canvas in\r\n   * @param {number} options.fftSize - The FFT size for analysis. Must be a power of 2. High values may lead to heavy CPU cost\r\n   * @param {object} [options.audioContext=null] - The audio context to base analysis from\r\n   * @param {object} [options.inputNode=null] - The audio node to take source instead of player's one\r\n   * @param {boolean} [options.merged=false] - Merge channels into mono output **/\n  _inherits(VisuComponentStereo, _BaseComponent);\n  return _createClass(VisuComponentStereo, [{\n    key: \"_fillAttributes\",\n    value: function _fillAttributes(options) {\n      this._type = options.type;\n      this._player = options.player;\n      this._renderTo = options.renderTo;\n      this._fftSize = options.fftSize || 1024;\n      this._audioCtx = options.audioContext;\n      this._inputNode = options.inputNode;\n      this._merged = options.merged || false;\n    }\n\n    /** @method\r\n     * @name _buildUI\r\n     * @private\r\n     * @override\r\n     * @memberof VisuComponentStereo\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Create and configure canvas then append it to given DOM element.</blockquote> **/\n  }, {\n    key: \"_buildUI\",\n    value: function _buildUI() {\n      this._dom.container = document.createElement('DIV');\n      this._dom.container.classList.add(\"audio-\".concat(this._type));\n      this._canvasL = document.createElement('canvas');\n      this._canvasR = document.createElement('canvas');\n      this._canvasL.style.cssText = 'display:block;box-sizing:border-box;';\n      this._canvasR.style.cssText = 'display:block;box-sizing:border-box;';\n      this._ctxL = this._canvasL.getContext('2d');\n      this._ctxR = this._canvasR.getContext('2d');\n      this._ctxL.translate(0.5, 0.5);\n      this._ctxR.translate(0.5, 0.5);\n      this._dom.container.appendChild(this._canvasL);\n      this._dom.container.appendChild(this._canvasR);\n      this._renderTo.appendChild(this._dom.container);\n    }\n\n    /** @method\r\n     * @name _setAudioNodes\r\n     * @private\r\n     * @override\r\n     * @memberof VisuComponentStereo\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Build audio chain with source -> splitter -> analyzerL/R -> merger -> destination.</blockquote> **/\n  }, {\n    key: \"_setAudioNodes\",\n    value: function _setAudioNodes() {\n      var audioCtxSent = false;\n      if (!this._audioCtx) {\n        this._audioCtx = new AudioContext();\n        this._nodes.source = this._audioCtx.createMediaElementSource(this._player);\n      } else {\n        audioCtxSent = true;\n        this._nodes.source = this._inputNode;\n      }\n      var outputNode;\n      if (this._merged === true) {\n        this._nodes.analyser = this._audioCtx.createAnalyser();\n        this._nodes.analyser.fftSize = this._fftSize;\n        // Nodes chaining\n        this._nodes.source.connect(this._nodes.analyser);\n        outputNode = this._nodes.analyser;\n      } else {\n        this._nodes.splitter = this._audioCtx.createChannelSplitter(this._nodes.source.channelCount);\n        this._nodes.merger = this._audioCtx.createChannelMerger(this._nodes.source.channelCount);\n        this._nodes.analyserL = this._audioCtx.createAnalyser();\n        this._nodes.analyserR = this._audioCtx.createAnalyser();\n        this._nodes.analyserR.fftSize = this._fftSize;\n        this._nodes.analyserL.fftSize = this._fftSize;\n        // Nodes chaining\n        this._nodes.source.connect(this._nodes.splitter);\n        this._nodes.splitter.connect(this._nodes.analyserL, 0);\n        this._nodes.splitter.connect(this._nodes.analyserR, 1);\n        this._nodes.analyserL.connect(this._nodes.merger, 0, 0);\n        this._nodes.analyserR.connect(this._nodes.merger, 0, 1);\n        outputNode = this._nodes.merger;\n      }\n      if (!audioCtxSent) {\n        outputNode.connect(this._audioCtx.destination);\n      } else {\n        // If any previous context exists, we mute this channel to not disturb any playback\n        var gainNode = this._audioCtx.createGain();\n        gainNode.gain.value = 0;\n        outputNode.connect(gainNode);\n        gainNode.connect(this._audioCtx.destination);\n      }\n    }\n\n    /** @method\r\n     * @name _clearCanvas\r\n     * @private\r\n     * @override\r\n     * @memberof VisuComponentStereo\r\n     * @author Arthur Beaulieu\r\n     * @since 2020\r\n     * @description <blockquote>Clear component canvas contexts from their content.</blockquote> **/\n  }, {\n    key: \"_clearCanvas\",\n    value: function _clearCanvas() {\n      this._canvasL.getContext('2d').clearRect(0, 0, this._canvasL.width, this._canvasL.height);\n      this._canvasR.getContext('2d').clearRect(0, 0, this._canvasR.width, this._canvasR.height);\n    }\n  }]);\n}(_BaseComponent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VisuComponentStereo);\n\n//# sourceURL=webpack://AudioVisualizer/./src/js/utils/VisuComponentStereo.js?");

/***/ }),

/***/ "./src/scss/audiovisualizer.scss":
/*!***************************************!*\
  !*** ./src/scss/audiovisualizer.scss ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://AudioVisualizer/./src/scss/audiovisualizer.scss?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/AudioVisualizer.js");
/******/ 	window.AudioVisualizer = __webpack_exports__["default"];
/******/ 	
/******/ })()
;